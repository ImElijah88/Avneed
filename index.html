<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avneed AI Features</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/pmrem/PMREMGenerator.js"></script>

    <style>
        /* CSS Variables for Theming */
        :root {
            --bg-primary: transparent; /* Changed to transparent to show background video */
            --bg-secondary: #1a1a2e;
            --bg-card: #121212;
            --input-bg: #1a1a1a;

            --text-primary: #f1cd04;
            --text-secondary: hsl(176, 96%, 52%);
            --text-light-gray: #5e6977;

            --border-color: #4a5568;
            --gradient-start: #0f172a;
            --gradient-mid: #1e293b;
            --gradient-end: #334155;

            --color-neon-blue: #00FFFF;
            --color-accent-yellow: #ffd700;

            --modal-bg: rgba(0, 0, 0, 0.8);
            --modal-content-bg: var(--bg-secondary);

            --font-heading: 'Orbitron', sans-serif;
            --font-body: 'Inter', sans-serif;
        }

        /* Light Theme Overrides */
        body.light-theme {
            --bg-primary: transparent; /* Changed to transparent to show background video */
            --bg-secondary: #ebcc04d5;
            --bg-card: #e2e8f0;
            --input-bg: #ffffff;

            --text-primary: #29d1d6;
            --text-secondary: #4a5568;
            --text-light-gray: #718096;

            --border-color: #cbd5e1;
            --gradient-start: #e0e7ff;
            --gradient-mid: #c3dafe;
            --gradient-end: #a7c5ff;

            --color-neon-blue: #007bff;
            --color-accent-yellow: #ff9800;

            --modal-bg: rgba(255, 255, 255, 0.8);
            --modal-content-bg: var(--bg-secondary);
        }

        /* Global Body and Heading Styles */
        body {
            font-family: var(--font-body);
            color: var(--text-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 0;
            box-sizing: border-box;
            gap: 2rem;
            line-height: 1.6;
            font-size: 1.05rem;
            position: relative; /* Needed for video positioning */
            background-color: #000; /* Fallback background color */
        }
        
        h1, h2, h3 {
            font-family: var(--font-heading);
            line-height: 1.2;
        }

        /* Background Video Styles */
        #background-video {
            position: fixed;
            right: 0;
            bottom: 0;
            min-width: 100%;
            min-height: 100%;
            width: auto;
            height: auto;
            z-index: -1;
            background-size: cover;
            object-fit: cover; /* Ensures the video covers the area without distortion */
        }

        /* Video Overlay for Readability */
        .video-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3); /* Semi-transparent dark overlay - adjusted opacity */
            z-index: -1; /* Below content, above video */
        }

        /* Neon Text and Gradient Backgrounds */
        .text-neon-blue { color: var(--color-neon-blue); }
        .gradient-bg { background: linear-gradient(to right top, var(--gradient-start), var(--gradient-mid), var(--gradient-end)); }
        
        .filter-drop-shadow-neon-blue {
            filter: drop-shadow(0 0 5px var(--color-neon-blue)) drop_shadow(0 0 15px rgba(0, 255, 255, 0.5));
        }

        .avneed-neon-text {
            font-family: var(--font-heading);
            font-weight: 700;
            font-size: 2.5rem;
            color: var(--color-neon-blue);
            text-shadow: 0 0 10px var(--color-neon-blue), 0 0 20px var(--color-neon-blue), 0 0 30px var(--color-neon-blue),
                         0 0 40px rgba(0, 255, 255, 0.5), 0 0 70px rgba(0, 255, 255, 0.3);
            animation: neon-pulse 1.5s ease-in-out infinite alternate,
                       flame-flicker 0.5s infinite alternate;
        }

        @keyframes neon-pulse {
            0% {
                text-shadow: 0 0 10px var(--color-neon-blue), 0 0 20px var(--color-neon-blue), 0 0 30px var(--color-neon-blue),
                             0 0 40px rgba(0, 255, 255, 0.5), 0 0 70px rgba(0, 255, 255, 0.3);
                transform: scale(1);
            }
            100% {
                text-shadow: 0 0 15px var(--color-neon-blue), 0 0 25px var(--color-neon-blue), 0 0 40px var(--color-neon-blue),
                             0 0 50px rgba(0, 255, 255, 0.7), 0 0 80px rgba(0, 255, 255, 0.5);
                transform: scale(1.02);
            }
        }

        @keyframes flame-flicker {
            0% {
                transform: skewX(0deg) translateY(0);
                text-shadow: 0 0 10px var(--color-neon-blue), 0 0 20px var(--color-neon-blue), 0 0 30px var(--color-neon-blue);
            }
            25% {
                transform: skewX(0.5deg) translateY(-1px);
                text-shadow: 0 0 8px var(--color-neon-blue), 0 0 18px var(--color-neon-blue), 0 0 28px var(--color-neon-blue);
            }
            50% {
                transform: skewX(-0.5deg) translateY(1px);
                text-shadow: 0 0 12px var(--color-neon-blue), 0 0 22px var(--color-neon-blue), 0 0 32px var(--color-neon-blue);
            }
            75% {
                transform: skewX(0.3deg) translateY(-0.5px);
                text-shadow: 0 0 9px var(--color-neon-blue), 0 0 19px var(--color-neon-blue), 0 0 29px var(--color-neon-blue);
            }
            100% {
                transform: skewX(0deg) translateY(0);
                text-shadow: 0 0 10px var(--color-neon-blue), 0 0 20px var(--color-neon-blue), 0 0 30px var(--color-neon-blue);
            }
        }

        /* AI Button Styles */
        .ai-button {
            @apply px-6 py-3 rounded-full text-white font-bold text-base shadow-lg transition duration-300 ease-in-out transform hover:scale-105;
            background: #2d3748;
            border: 2px solid var(--border-color);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            font-family: var(--font-body);
            font-weight: 600;
        }
        .ai-button:hover {
            background: #374151;
            box-shadow: 0 0 25px 8px rgba(0, 255, 255, 0.7), 0 0 10px 2px rgba(0, 255, 255, 0.4); /* Neon blue hover */
            border-color: var(--color-neon-blue);
        }

        .ai-button.selected-button {
            background: var(--color-neon-blue);
            color: var(--bg-primary);
            border-color: var(--color-neon-blue);
            box-shadow: 0 0 20px var(--color-neon-blue), 0 0 30px var(--color-neon-blue);
            transform: scale(1.02);
        }
        .ai-button.selected-button:hover {
            background: var(--color-neon-blue);
            color: var(--bg-primary);
            box-shadow: 0 0 25px var(--color-neon-blue), 0 0 40px var(--color-neon-blue);
            border-color: var(--color-neon-blue);
        }

        /* Adjustments for .ai-button in Light Theme */
        body.light-theme .ai-button {
            background-color: #e2e8f0; /* Explicitly set a light background */
            color: var(--text-primary); /* Use dark text color */
            border-color: var(--border-color); /* Adjust border for light theme */
        }
        body.light-theme .ai-button:hover {
            background-color: var(--color-neon-blue); /* Keep neon hover for consistency */
            color: var(--bg-primary); /* Keep dark text on neon hover */
            border-color: var(--color-neon-blue);
        }
        body.light-theme .ai-button.selected-button {
            background-color: var(--color-neon-blue); /* Neon blue background */
            color: var(--bg-primary); /* Dark text on neon blue */
            border-color: var(--color-neon-blue);
            box-shadow: 0 0 20px var(--color-neon-blue), 0 0 30px var(--color-neon-blue);
        }
        body.light-theme .ai-button.selected-button:hover {
            background-color: var(--color-neon-blue);
            color: var(--bg-primary);
            box-shadow: 0 0 25px var(--color-neon-blue), 0 0 40px var(--color-neon-blue);
            border-color: var(--color-neon-blue);
        }


        /* Sphere Button Styles (Floating Buttons) */
        .sphere-button {
            /* Removed w-15 h-15 from @apply as explicit width/height are used */
            border-radius: 9999px;
            background: #2d3748;
            border: 2px solid var(--border-color);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            cursor: pointer;
            flex-shrink: 0;
            font-family: var(--font-body);
            font-weight: 600;
            position: absolute; /* Crucial for independent movement */
            transition: transform 0.3s ease-in-out, background 0.3s ease, border-color 0.3s ease, box-shadow 0.3s ease; /* Added transition for hover */

            /* Adjusted for smaller size */
            width: 80px; 
            height: 80px;
            font-size: 0.7rem; 
            display: inline-flex; /* Changed to inline-flex */
            justify-content: center; /* Center content horizontally */
            align-items: center; /* Center content vertically */
            text-align: center; /* Ensure text itself is centered within the flex item */
            line-height: 1; /* Adjust line height for single line text */
            padding: 0.2rem; /* Add some padding to prevent text from touching edges */
        }
        .sphere-button:hover {
            background: #374151;
            box-shadow: 0 0 25px 8px rgba(0, 255, 255, 0.7), 0 0 10px 2px rgba(0, 255, 255, 0.4); /* Neon blue hover */
            border-color: var(--color-neon-blue);
            transform: scale(1.1); /* Hover scale effect */
        }
        .sphere-button.neon-hover:hover {
            background: var(--color-neon-blue);
            color: var(--bg-primary);
            box-shadow: 0 0 25px 8px rgba(0, 255, 255, 0.7), 0 0 10px 2px rgba(0, 255, 255, 0.4);
            border-color: var(--color-neon-blue);
        }

        /* Card and Input Field Styles */
        .card {
            background-color: var(--bg-card);
            @apply p-8 rounded-[2.5rem] shadow-xl transition duration-300 ease-in-out hover:shadow-2xl hover:translate-y-[-5px];
            border: 1px solid rgba(74, 85, 104, 0.3);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
        }
        .input-field {
            background-color: var(--input-bg);
            color: var(--text-primary);
            @apply p-4 rounded-2xl border border-gray-700 focus:outline-none focus:ring-4 focus:ring-purple-600 transition duration-200 ease-in-out;
            border-color: var(--border-color);
            font-family: var(--font-body);
            font-size: 1rem;
        }
        
        /* Loading Spinner */
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-top: 4px solid var(--color-accent-yellow);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Tailwind Color Variable Mapping */
        .text-gray-100 { color: var(--text-primary); }
        .text-gray-200 { color: var(--text-secondary); }
        .text-gray-300 { color: var(--text-light-gray); }
        .text-gray-400 { color: var(--text-light-gray); }
        .text-gray-500 { color: var(--text-light-gray); }
        .text-gray-700 { border-color: var(--border-color); }
        .bg-gray-800 { background-color: var(--bg-card); }
        .bg-gray-900 { background-color: var(--bg-secondary); }
        .bg-gray-950 { background-color: var(--bg-card); }
        .bg-[#1a1a1a] { background-color: var(--input-bg); }
        .text-yellow-400 { color: var(--color-accent-yellow); }

        /* 3D Viewer Specific Styles */
        .model-viewer-container {
            position: relative;
            width: 100%;
            height: 450px;
            background-color: transparent;
            border-radius: 2.5rem;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            border: 1px solid var(--border-color);
        }
        .model-viewer-canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 2.5rem;
        }
        .model-status {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--color-accent-yellow);
            font-size: 1.25rem;
            font-weight: 600;
            text-align: center;
            z-index: 10;
            font-family: var(--font-body);
        }
        .model-file-input-label {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            width: 50px;
            height: 50px;
            background: #2d3748;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            color: var(--text-primary);
            cursor: pointer;
            z-index: 15;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .model-file-input-label:hover {
            background: #374151;
            color: var(--color-neon-blue);
            box-shadow: 0 0 25px 8px rgba(0, 255, 255, 0.7), 0 0 10px 2px rgba(0, 255, 255, 0.4);
            border-color: var(--color-neon-blue);
            transform: scale(1.1);
        }
        .hidden-file-input {
            display: none !important;
            width: 0;
            height: 0;
            overflow: hidden;
            position: absolute;
            opacity: 0;
            pointer-events: none;
        }

        .resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            background-color: rgba(0, 255, 255, 0.5);
            border-radius: 0 0 2.5rem 0;
            cursor: nwse-resize;
            z-index: 20;
        }

        .model-controls {
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            z-index: 15;
            background: rgba(45, 55, 72, 0.7);
            padding: 0.5rem;
            border-radius: 1rem;
            border: 1px solid rgba(74, 85, 104, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }

        .model-control-button {
            @apply px-1 py-0.5 rounded-md text-white font-bold text-xs transition duration-300 ease-in-out transform hover:scale-105;
            background: #2d3748;
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: var(--font-body);
            font-weight: 500;
        }
        .model-control-button:hover {
            background: #374151;
            color: var(--color-neon-blue);
            box-shadow: 0 0 10px 3px rgba(0, 255, 255, 0.5);
            border-color: var(--color-neon-blue);
        }
        .model-controls .grid-cols-3 .model-control-button {
            width: 30px;
            height: 30px;
            font-size: 1rem;
        }
        .model-control-button.toggle-lock {
            width: 100%;
        }

        .upload-menu {
            position: absolute;
            top: 65px;
            right: 1.5rem;
            background: rgba(45, 55, 72, 0.9);
            padding: 0.75rem;
            border-radius: 0.75rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            border: 1px solid rgba(74, 85, 104, 0.3);
        }

        .upload-menu-button {
            @apply px-4 py-2 rounded-md text-white font-bold text-sm transition duration-300 ease-in-out transform hover:scale-105;
            background: #2d3748;
            border: 1px solid #4a5568;
            cursor: pointer;
            font-family: var(--font-body);
            font-weight: 600;
        }
        .upload-menu-button:hover {
            background: #374151;
            color: var(--color-neon-blue);
            box-shadow: 0 0 10px 3px rgba(0, 255, 255, 0.5);
            border-color: var(--color-neon-blue);
        }

        .audio-controls {
            position: absolute;
            top: 1.5rem;
            left: 1.5rem;
            width: 50px;
            height: 50px;
            background: #2d3748;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            color: var(--text-primary);
            cursor: pointer;
            z-index: 15;
            transition: all 0.3s ease-in-out;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .audio-controls:hover {
            background: #374151;
            color: var(--color-neon-blue);
            box-shadow: 0 0 25px 8px rgba(0, 255, 255, 0.7), 0 0 10px 2px rgba(0, 255, 255, 0.4);
            border-color: var(--color-neon-blue);
            transform: scale(1.1);
        }
        .audio-play-pause-button {
            background: none;
            border: none;
            color: inherit;
            font-size: inherit;
            cursor: inherit;
            padding: 0;
            margin: 0;
            line-height: 1;
        }

        /* New style for the plus button */
        .audio-add-button {
            background: none;
            border: none;
            color: inherit;
            font-size: 1.5rem; /* Smaller than play/pause, but still visible */
            cursor: inherit;
            padding: 0;
            margin-left: 0.25rem; /* Small spacing */
            line-height: 1;
            transition: color 0.3s ease;
        }
        .audio-add-button:hover {
            color: var(--color-accent-yellow); /* Different hover color for distinction */
        }


        /* Settings Button */
        #settingsBtn {
            font-size: 2.5rem;
            cursor: pointer;
            transition: transform 0.3s ease-in-out;
            color: var(--color-neon-blue);
            text-shadow: 0 0 8px var(--color-neon-blue), 0 0 15px rgba(0, 255, 255, 0.7);
            filter: drop_shadow(0 0 6px var(--color-neon-blue)) drop_shadow(0 0 10px rgba(0, 255, 255, 0.5));
        }
        #settingsBtn:hover {
            color: var(--color-neon-blue);
            text-shadow: 0 0 12px var(--color-neon-blue), 0 0 20px rgba(0, 255, 255, 0.9);
            filter: drop_shadow(0 0 8px var(--color-neon-blue)) drop_shadow(0 0 15px rgba(0, 255, 255, 0.7));
            transform: rotate(90deg); /* Added rotate on hover */
        }

        /* Settings Menu */
        .settings-menu {
            position: absolute;
            top: 80px;
            right: 20px;
            background: rgba(45, 55, 72, 0.95);
            padding: 1rem;
            border-radius: 1rem;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            border: 1px solid rgba(74, 85, 104, 0.5);
            min-width: 250px;
        }

        .settings-menu-button {
            @apply px-4 py-2 rounded-md text-white font-bold text-sm transition duration-300 ease-in-out transform hover:scale-105;
            background: #2d3748;
            border: 1px solid #4a5568;
            cursor: pointer;
            width: 100%;
            text-align: left;
            font-family: var(--font-body);
            font-weight: 600;
        }
        .settings-menu-button:hover {
            background: #374151;
            color: var(--color-neon-blue);
            box-shadow: 0 0 10px 3px rgba(0, 255, 255, 0.5);
            border-color: var(--color-neon-blue);
        }
        .settings-menu .account-section {
            padding: 0.5rem;
            border-radius: 0.75rem;
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
        }
        .settings-menu .account-section h3 {
            font-size: 1.2rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .settings-menu .account-section p {
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            text-align: center;
        }
        .settings-menu .account-section .ai-button {
            width: 100%;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
            padding: 0.5rem 1rem;
        }
        .settings-menu .account-section .ai-button:last-child {
            margin-bottom: 0;
        }
        .settings-menu .account-section .flex.gap-2 .ai-button {
            width: auto;
            flex-grow: 1;
        }

        /* Login Options Modal Styles (Kept as a modal for now, separate from feature content) */
        #loginOptionsModal .modal-content {
            max-width: 400px;
            padding: 1.5rem;
            border-radius: 2rem;
        }
        #loginOptionsModal .modal-content h2 {
            font-size: 2rem;
            margin-bottom: 1rem;
        }
        #loginOptionsModal .modal-content p {
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
        }
        #loginOptionsModal .modal-content .ai-button {
            font-size: 1rem;
            padding: 0.75rem 1.5rem;
            margin-bottom: 0.75rem;
        }
        #loginOptionsModal .modal-content .ai-button:last-child {
            margin-bottom: 0;
        }

        /* Chat History Styles */
        #chatbotHistory p {
            font-size: 1rem;
            line-height: 1.5;
            margin-bottom: 0.5rem;
            padding: 0.75rem;
            border-radius: 0.75rem;
            max-width: 75%;
            font-family: var(--font-body);
        }

        #chatbotHistory p.user-message {
            margin-left: auto;
            background-color: var(--color-neon-blue);
            color: #000000; /* Changed to black for visibility */
            font-weight: 600;
            border-bottom-right-radius: 0.25rem;
        }
        #chatbotHistory p.ai-message {
            margin-right: auto;
            background-color: var(--color-accent-yellow);
            color: #000000; /* Changed to black for visibility */
            border-bottom-left-radius: 0.25rem;
        }

        /* Textarea and Input Field Sizing */
        #aiInputText, #imagePromptInput, #videoPromptInput, #userNotesInput, #chatbotInputText, #imageGenPromptInput, #imageAnalysisPromptInput, #audioTranscriptionOutput {
            min-height: 2.5rem;
            max-height: 152px;
            overflow-y: hidden;
            box-sizing: border-box;
            font-family: var(--font-body);
            font-size: 1rem;
        }

        /* Glitch Text Animation */
        .glitch-text {
            animation: glitch 0.8s linear infinite alternate, neon-pulse 0.8s ease-in-out forwards;
        }

        @keyframes glitch {
            0% {
                text-shadow: 0.05em 0 0 var(--color-neon-blue), -0.05em -0.025em 0 var(--color-accent-yellow), -0.025em 0.05em 0 var(--color-neon-blue);
                transform: translate(0.01em, 0.01em);
            }
            15% {
                text-shadow: 0.025em 0.05em 0 var(--color-accent-yellow), -0.025em -0.01em 0 var(--color-neon-blue), 0.05em -0.025em 0 var(--color-accent-yellow);
                transform: translate(-0.01em, -0.02em);
            }
            30% {
                text-shadow: -0.025em -0.05em 0 var(--color-neon-blue), 0.05em 0.025em 0 var(--color-accent-yellow), 0.01em 0.01em 0 var(--color-neon-blue);
                transform: translate(0.02em, 0.01em);
            }
            45% {
                text-shadow: 0.05em 0.01em 0 var(--color-accent-yellow), -0.01em -0.05em 0 var(--color-neon-blue), -0.05em 0.025em 0 var(--color-accent-yellow);
                transform: translate(-0.01em, -0.01em);
            }
            60% {
                text-shadow: -0.01em -0.025em 0 var(--color-neon-blue), 0.025em 0.05em 0 var(--color-accent-yellow), 0.05em -0.01em 0 var(--color-neon-blue);
                transform: translate(0.01em, 0.02em);
            }
            75% {
                text-shadow: 0.025em 0.01em 0 var(--color-accent-yellow), -0.05em -0.025em 0 var(--color-neon-blue), -0.01em 0.05em 0 var(--color-accent-yellow);
                transform: translate(-0.02em, 0.01em);
            }
            100% {
                color: var(--text-primary);
                text-shadow: none;
                transform: scale(1);
            }
        }

        /* Image Frame and Loading Styles */
        .image-frame-container, .video-player-container {
            background-color: var(--bg-card);
            border: 5px solid var(--color-neon-blue);
            border-radius: 1.5rem;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.6),
                        0 0 30px rgba(0, 255, 255, 0.4) inset,
                        0 15px 30px rgba(0, 0, 0, 0.7);
            padding: 1.5rem;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
            transition: all 0.3s ease-in-out;
            transform: rotateZ(-1deg);
            max-width: 100%;
            margin: 0 auto;
            animation: neon-pulse-frame 2s infinite alternate;
        }

        @keyframes neon-pulse-frame {
            0% {
                box-shadow: 0 0 15px rgba(0, 255, 255, 0.6),
                            0 0 30px rgba(0, 255, 255, 0.4) inset,
                            0 15px 30px rgba(0, 0, 0, 0.7);
            }
            100% {
                box-shadow: 0 0 25px rgba(0, 255, 255, 0.9),
                            0 0 40px rgba(0, 255, 255, 0.6) inset,
                            0 15px 30px rgba(0, 0, 0, 0.9);
            }
        }

        .image-frame-container::before, .video-player-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: repeating-linear-gradient(0deg, rgba(0, 255, 255, 0.05) 0px, rgba(0, 255, 255, 0.05) 1px, transparent 1px, transparent 20px),
                              repeating-linear-gradient(90deg, rgba(0, 255, 255, 0.05) 0px, rgba(0, 255, 255, 0.05) 1px, transparent 1px, transparent 20px);
            pointer-events: none;
            z-index: 1;
            border-radius: 1rem;
        }

        .generated-image, .generated-video {
            position: relative;
            z-index: 2;
            display: block;
            width: 100%;
            height: 100%;
            object-fit: contain;
            border-radius: 0.5rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5) inset;
            transition: opacity 0.3s ease-in-out;
        }

        .image-frame-container.aspect-1-1 { width: 400px; height: 400px; }
        .image-frame-container.aspect-16-9 { width: 640px; height: 360px; }
        .image-frame-container.aspect-4-3 { width: 500px; height: 375px; }
        .image-frame-container.aspect-9-16 { width: 360px; height: 640px; }

        @media (max-width: 768px) {
            .image-frame-container.aspect-1-1 { width: 300px; height: 300px; }
            .image-frame-container.aspect-16-9 { width: 90%; height: calc(90vw * 9 / 16); max-height: 300px; }
            .image-frame-container.aspect-4-3 { width: 90%; height: calc(90vw * 3 / 4); max-height: 300px; }
            .image-frame-container.aspect-9-16 { width: calc(90vw * 9 / 16); height: 90vw; max-width: 200px; max-height: 350px; }
        }

        .image-loading-overlay, .video-loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 1.2rem;
            border-radius: 1rem;
            z-index: 10;
            font-family: var(--font-body);
        }

        .image-loading-spinner, .video-loading-spinner {
            border: 5px solid rgba(255, 255, 255, 0.3);
            border-top: 5px solid var(--color-neon-blue);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 1rem;
        }

        /* Modal Overlays (Only for Login Modal now) */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--modal-bg);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background-color: var(--modal-content-bg);
            padding: 1.5rem;
            border-radius: 2rem;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            transform: translateY(-50px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            border: 1px solid var(--border-color);
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .modal-overlay.visible .modal-content {
            transform: translateY(0);
            opacity: 1;
        }

        .modal-close-button {
            position: absolute;
            top: 0.8rem;
            right: 0.8rem;
            background: var(--bg-card);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 50%;
            width: 35px;
            height: 35px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.3rem;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            z-index: 1010;
        }
        .modal-close-button:hover {
            background: var(--color-neon-blue);
            color: var(--bg-primary);
            border-color: var(--color-neon-blue);
            transform: scale(1.1);
        }

        /* AI Feature Content General Styles */
        .ai-feature-content {
            width: 100%; /* Take full width of its container */
            max-width: 100%; /* Ensure it doesn't overflow */
            margin-left: auto;
            margin-right: auto;
            background-color: var(--bg-secondary); /* Use secondary background for features */
            padding: 2rem;
            border-radius: 2.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
            border: 1px solid var(--border-color);
            transition: all 0.3s ease-in-out;
            display: flex; /* Make it a flex container */
            flex-direction: column; /* Stack children vertically */
            gap: 1rem; /* Spacing between elements */
            min-height: 400px; /* Minimum height for features */
            position: relative; /* Needed for close button positioning */
        }

        .ai-feature-content h2 {
            font-size: 2.2rem;
            margin-bottom: 1rem; /* Adjusted margin */
            text-align: center;
        }

        .ai-feature-content p {
            font-size: 0.95rem;
            line-height: 1.6;
        }

        .ai-feature-content .card {
            padding: 1.5rem;
            border-radius: 1.5rem;
        }
        .ai-feature-content .input-field {
            font-size: 0.95rem;
            padding: 0.75rem;
        }
        .ai-feature-content #chatHistory p {
            font-size: 0.9rem;
            padding: 0.6rem;
            margin-bottom: 0.3rem;
        }
        .ai-feature-content .loading-spinner {
            width: 25px;
            height: 25px;
        }
        .ai-feature-content .ai-button {
            font-size: 0.9rem;
            padding: 0.6rem 1rem;
        }

        /* Responsive Adjustments */
        @media (max-width: 640px) {
            body {
                font-size: 0.95rem;
            }
            .modal-content {
                max-width: 95%;
                padding: 1rem;
                border-radius: 1.5rem;
            }
            .ai-feature-content {
                padding: 1rem;
                border-radius: 1.5rem;
                min-height: 300px;
            }
            .ai-feature-content h2 {
                font-size: 1.8rem;
            }
            .ai-feature-content p {
                font-size: 0.85rem;
            }
            .ai-feature-content .input-field {
                font-size: 0.85rem;
            }
            .ai-feature-content #chatHistory p {
                font-size: 0.8rem;
            }
            .ai-feature-content .ai-button {
                font-size: 0.8rem;
                padding: 0.5rem 0.8rem;
            }
            .avneed-neon-text {
                font-size: 2rem;
            }
            #settingsBtn {
                font-size: 2.2rem;
            }
            .sphere-button {
                width: 60px; /* Adjusted size for smaller screens */
                height: 60px;
                font-size: 0.7rem;
            }
        }
        /* New style for bigger Features text */
        .features-text {
            font-size: 1.5rem;
            font-weight: 700;
        }

        /* Global Music Controls Styles */
        .music-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(45, 55, 72, 0.7);
            padding: 0.5rem 0.75rem;
            border-radius: 1rem;
            border: 1px solid rgba(74, 85, 104, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
        }
        .music-controls button {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 1.5rem;
            cursor: pointer;
            transition: color 0.3s ease;
        }
        .music-controls button:hover {
            color: var(--color-neon-blue);
        }
        .music-controls input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 8px;
            background: var(--border-color);
            border-radius: 5px;
            outline: none;
            transition: background 0.2s ease-in-out;
        }
        .music-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--color-neon-blue);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.7);
        }
        .music-controls input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: var(--color-neon-blue);
            cursor: pointer;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.7);
        }

        /* Simulated Full Screen Mode Styles */
        body.simulated-fullscreen-active {
            overflow: hidden; /* Prevent scrolling of the main page */
        }

        body.simulated-fullscreen-active #sectionHeader {
            display: none; /* Hide the header in simulated full screen */
        }

        /* This targets the feature content when simulated fullscreen is active */
        body.simulated-fullscreen-active .ai-feature-content {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            max-width: 100vw; /* Ensure it takes full viewport width */
            max-height: 100vh; /* Ensure it takes full viewport height */
            border-radius: 0; /* Remove rounded corners in simulated full screen */
            padding: 1rem; /* Adjust padding for simulated full screen */
            box-shadow: none; /* Remove shadows in simulated full screen */
            overflow: auto; /* Allow internal scrolling if content is large */
            background-color: var(--bg-secondary); /* Ensure background is consistent */
            z-index: 9999; /* Ensure it's on top */
            margin: 0 !important; /* Override any margins */
        }

        /* Hide the full-screen toggle button when in simulated fullscreen */
        body.simulated-fullscreen-active .full-screen-toggle-button {
            display: none;
        }

        /* The close button should remain visible and fixed in simulated full screen */
        body.simulated-fullscreen-active .close-feature-button {
            position: fixed; /* Keep it fixed relative to viewport */
            top: 1rem;
            right: 1rem;
            z-index: 10000; /* Ensure it's above the simulated fullscreen content */
        }

        /* Hide the music controls and settings button when in simulated full screen */
        body.simulated-fullscreen-active .music-controls,
        body.simulated-fullscreen-active #settingsBtn {
            display: none;
        }

        /* Styles for expanded header (where balls move) */
        #sectionHeader {
            /* Initial state */
            min-height: 200px; /* Default height to contain balls comfortably */
            transition: all 0.5s ease-in-out; /* Smooth transition for size changes */
        }

        #sectionHeader.expanded-header {
            max-width: 90%; /* Make it wider */
            width: 100%; /* Ensure it takes full width up to max-width */
            min-height: 600px; /* Make it significantly taller when expanded */
            height: auto; /* Allow height to adjust based on content */
            padding-bottom: 2rem; /* Ensure enough space at the bottom for balls */
        }

        @media (max-width: 768px) {
            #sectionHeader.expanded-header {
                max-width: 95%; /* Adjust for smaller screens */
                min-height: 400px; /* Smaller height for mobile */
            }
        }

        /* Custom class for transparent header background and no shadow */
        .header-no-shadow {
            box-shadow: none !important;
        }
    </style>
</head>
<body>
    <!-- Background Video -->
    <video autoplay loop muted playsinline id="background-video">
        <source src="https://imelijah88.github.io/Avneed/videoground.mp4" type="video/mp4">
        Your browser does not support the video tag.
    </video>
    <!-- Video Overlay for readability -->
    <div class="video-overlay"></div>

    <section id="ai-features" class="pt-4 px-6 bg-transparent text-center flex flex-col items-center align-items-start min-h-screen relative perspective-1000 pb-20">
        <div id="sectionHeader" class="bg-transparent text-white p-6 rounded-[2.5rem] header-no-shadow w-full max-w-4xl relative flex flex-col flex-grow overflow-hidden">
            <!-- Fixed header content (logo, Avneed text, navigation) -->
            <div id="fixedHeaderContent" class="flex justify-between items-center z-10 relative">
                <div class="flex items-center space-x-2">
                    <img src="https://imelijah88.github.io/Avneed/logo.png" alt="Avneed AI Logo" class="h-10 md:h-12 lg:h-14 w-auto object-contain filter-drop-shadow-neon-blue">
                    <span class="avneed-neon-text">Avneed</span>
                </div>
                <nav class="flex items-center space-x-8 font-semibold">
                    <ul class="flex space-x-8">
                        <li><a href="#ai-features" id="featuresLink" class="features-text hover:text-yellow-300 transition duration-300 transform hover:scale-105">Features</a></li>
                    </ul>
                    <!-- Global Music Controls -->
                    <div class="music-controls">
                        <audio id="backgroundMusicPlayer" loop>
                            <!-- Default background music. You can change this URL. -->
                            <source src="https://imelijah88.github.io/Avneed/audioAvneed.mp3" type="audio/mpeg">
                        </audio>
                        <button id="playPauseMusicBtn" aria-label="Play/Pause Background Music">▶</button>
                        <input type="range" id="musicVolumeSlider" min="0" max="1" step="0.01" value="0.5" aria-label="Music Volume">
                    </div>
                    <button id="settingsBtn" class="ml-4" aria-label="Settings">⚙️</button>
                </nav>
            </div>
            <!-- Settings Menu - positioned absolutely within sectionHeader -->
            <div id="settingsMenu" class="settings-menu hidden">
                <div id="loginLogoutContainer">
                    <!-- Content will be dynamically loaded here by JS -->
                </div>
                <button class="settings-menu-button" data-theme="dark">Dark Theme</button>
                <button class="settings-menu-button" data-theme="light">Light Theme</button>
            </div>

            <!-- Floating buttons are now directly inside sectionHeader, below fixedHeaderContent -->
            <button id="openProjectNotesBtn" class="sphere-button neon-hover" aria-label="Open Project Notes" data-feature-id="projectNotesContent">Notes</button>
            <button id="openAvneedChatbotBtn" class="sphere-button neon-hover" aria-label="Open Chatbot" data-feature-id="chatbotContent">Chat</button>
            <button id="openImageGeneratorBtn" class="sphere-button neon-hover" aria-label="Open Image Generator" data-feature-id="imageGeneratorContent">Image Gen</button>
            <button id="openImageAnalysisBtn" class="sphere-button neon-hover" aria-label="Open Image Analysis" data-feature-id="imageAnalysisContent">Image Analysis</button>
            <button id="openAudioTranscriptionBtn" class="sphere-button neon-hover" aria-label="Open Audio Transcription" data-feature-id="audioTranscriptionContent">Audio Trans</button>
            <button id="open3DViewerBtn" class="sphere-button neon-hover" aria-label="Open 3D Model Viewer" data-feature-id="threeDViewerContent">3D Viewer</button>
        </div>

        <!-- New Feature Display Area -->
        <div id="featureDisplayArea" class="mt-8 w-full max-w-4xl px-6">
            <!-- Feature content will be loaded here dynamically -->
        </div>
    </section>

    <!-- Login Options Modal (Kept as a modal for now) -->
    <div id="loginOptionsModal" class="modal-overlay" role="dialog" aria-modal="true" aria-labelledby="loginModalTitle">
        <div class="modal-content">
            <button class="modal-close-button" id="closeLoginModalBtn" aria-label="Close Login Modal">&times;</button>
            <div class="flex flex-col flex-grow text-center">
                <h2 id="loginModalTitle" class="text-4xl font-bold mb-6 text-gray-100 leading-tight">Account</h2>
                <p class="text-sm text-gray-300 mb-4">Manage your Avneed account.</p>
                <div class="flex flex-col gap-2 mb-2">
                    <button id="modalLoginBtnGoogle" class="ai-button">Log In with Google</button>
                    <button id="modalLoginBtnGithub" class="ai-button">Log In with GitHub</button>
                    <button id="modalLoginBtnGuest" class="ai-button">Continue as Guest</button>
                </div>
                <p id="modalLoginStatus" class="mt-1 text-center text-yellow-400 text-xs"></p>
            </div>
        </div>
    </div>


    <!-- Feature Templates (hidden, cloned and inserted into featureDisplayArea) -->
    <div id="projectNotesContent" class="ai-feature-content hidden">
        <h2 class="text-4xl font-bold mb-6 text-gray-100 leading-tight flex items-center justify-center gap-2">
            <img src="https://imelijah88.github.io/Avneed/logo.png" alt="Avneed AI Logo" class="h-8 w-auto object-contain filter-drop-shadow-neon-blue">
            Avneed Notes
        </h2>
        <div class="flex flex-col gap-4 mb-6 flex-grow">
            <textarea id="modalUserNotesInput" class="flex-grow input-field resize-none h-48" placeholder="Type your private project notes here..." aria-label="Your private project notes"></textarea>
            <div class="flex flex-row flex-wrap justify-center gap-4"> <!-- Modified: Added flex-wrap and justify-center -->
                <button id="modalSaveNotesBtn" class="ai-button w-1/2" disabled aria-label="Save Notes">Save Project Notes</button> <!-- Modified: Changed flex-grow to w-1/2 -->
                <label for="notesFileInput" class="ai-button w-1/2 flex items-center justify-center cursor-pointer">Upload Notes</label> <!-- Modified: Changed flex-shrink-0 to w-1/2 -->
                <input type="file" id="notesFileInput" accept=".txt" class="hidden-file-input">
            </div>
        </div>
        <p id="modalUserNotesStatus" class="mt-2 text-center text-gray-400 text-xs">Please log in to save notes.</p>
        <button class="full-screen-toggle-button" aria-label="Toggle Full Screen">⤢</button>
        <button class="modal-close-button close-feature-button" aria-label="Close Feature">&times;</button>
    </div>

    <div id="chatbotContent" class="ai-feature-content hidden">
        <h2 class="text-4xl font-bold mb-6 text-gray-100 leading-tight flex items-center justify-center gap-2">
            <img src="https://imelijah88.github.io/Avneed/logo.png" alt="Avneed AI Logo" class="h-8 w-auto object-contain filter-drop-shadow-neon-blue">
            Avneed Chat
        </h2>
        <div class="flex flex-col md:flex-row gap-4 mb-4">
            <select id="aiPersonaSelect" class="input-field flex-grow md:flex-grow-0 md:w-auto" aria-label="Select AI Persona">
                <option value="">Default Persona</option>
                <option value="therapist">Aether Therapist</option>
                <option value="business-consultant">Aether Business Consultant</option>
                <option value="study-buddy">Aether Study Buddy</option>
                <option value="creativity-coach">Aether Creativity Coach</option>
                <option value="fun-mode">Aether Fun Mode</option>
            </select>
            <label for="chatbotDocumentFileInput" class="ai-button flex-shrink-0 flex items-center justify-center cursor-pointer">Upload Document (.txt)</label>
            <input type="file" id="chatbotDocumentFileInput" accept=".txt" class="hidden-file-input">
        </div>
        <div id="chatbotHistory" class="bg-[#1a1a1a] p-4 rounded-xl shadow-md text-left text-gray-200 min-h-[200px] max-h-[300px] overflow-y-auto mb-4 border border-gray-700" aria-live="polite" aria-atomic="false">
            <p class="ai-message">Hello! How can I assist?</p>
        </div>
        
        <div class="flex gap-2 mb-2 items-end">
            <textarea id="chatbotInputText" class="flex-grow input-field resize-none" placeholder="Type message or ask about the uploaded document..." aria-label="Chat message input"></textarea>
            <button id="chatbotSendBtn" class="ai-button flex-shrink-0" aria-label="Send Message">Send</button>
        </div>

        <div id="chatbotLoadingIndicator" class="mt-2 text-center hidden" aria-live="polite" aria-busy="true">
            <div class="loading-spinner"></div>
            <p class="ml-1 text-gray-300 inline-block">Thinking...</p>
        </div>
        <p id="chatbotStatus" class="mt-2 text-center text-yellow-400 text-xs"></p>
        <button class="full-screen-toggle-button" aria-label="Toggle Full Screen">⤢</button>
        <button class="modal-close-button close-feature-button" aria-label="Close Feature">&times;</button>
    </div>

    <div id="imageGeneratorContent" class="ai-feature-content hidden">
        <h2 class="text-4xl font-bold mb-6 text-gray-100 leading-tight flex items-center justify-center gap-2">
            <img src="https://imelijah88.github.io/Avneed/logo.png" alt="Avneed AI Logo" class="h-8 w-auto object-contain filter-drop-shadow-neon-blue">
            Avneed Imagine
        </h2>
        <div class="flex flex-col gap-4 mb-6">
            <textarea id="imageGenPromptInput" class="flex-grow input-field resize-none" placeholder="Describe the image you want to generate..." aria-label="Image prompt input"></textarea>
            <div class="flex flex-row flex-wrap justify-center gap-4"> <!-- Added flex-wrap -->
                <button id="imageGenGenerateBtn" class="ai-button flex-grow" aria-label="Generate Image">Generate Image</button> <!-- Added flex-grow -->
                <select id="imageGenAspectRatio" class="ai-button bg-gray-800 flex-grow" aria-label="Image Aspect Ratio"> <!-- Added flex-grow -->
                    <option value="1-1">1:1 (Square)</option>
                    <option value="16-9">16:9 (Landscape)</option>
                    <option value="4-3">4:3 (Traditional)</option>
                    <option value="9-16">9:16 (Portrait)</option>
                </select>
            </div>
        </div>

        <div id="imageGenDisplayArea" class="image-frame-container aspect-1-1 relative mx-auto mt-8 hidden">
            <div id="imageGenLoadingOverlay" class="image-loading-overlay hidden">
                <div class="image-loading-spinner"></div>
                <p>Generating Image...</p>
            </div>
            <img id="imageGenGeneratedImage" class="generated-image" src="" alt="Generated AI Image" onerror="this.onerror=null;this.src='https://placehold.co/400x400/333333/FFFFFF?text=Image+Load+Error';" />
        </div>
        <p id="imageGenStatus" class="mt-4 text-center text-yellow-400 text-xs"></p>
        <button class="full-screen-toggle-button" aria-label="Toggle Full Screen">⤢</button>
        <button class="modal-close-button close-feature-button" aria-label="Close Feature">&times;</button>
    </div>

    <div id="imageAnalysisContent" class="ai-feature-content hidden">
        <h2 class="text-4xl font-bold mb-6 text-gray-100 leading-tight flex items-center justify-center gap-2">
            <img src="https://imelijah88.github.io/Avneed/logo.png" alt="Avneed AI Logo" class="h-8 w-auto object-contain filter-drop-shadow-neon-blue">
            Avneed Analyze
        </h2>
        <div class="flex flex-col gap-4 mb-6">
            <textarea id="imageAnalysisPromptInput" class="flex-grow input-field resize-none" placeholder="Ask a question about the image, or leave blank for a general description..." aria-label="Image analysis prompt"></textarea>
            <div class="flex flex-row flex-wrap justify-center gap-4"> <!-- New wrapper div for buttons -->
                <label for="imageAnalysisFileInput" class="ai-button flex-grow flex items-center justify-center cursor-pointer">Upload Image for Analysis</label> <!-- Added flex-grow -->
                <input type="file" id="imageAnalysisFileInput" accept="image/*" class="hidden-file-input">
                <button id="imageAnalysisAnalyzeBtn" class="ai-button flex-grow" disabled>Analyze Image</button> <!-- Added flex-grow -->
            </div>
        </div>

        <div id="imageAnalysisDisplayArea" class="image-frame-container aspect-1-1 relative mx-auto mt-8 hidden">
            <div id="imageAnalysisLoadingOverlay" class="image-loading-overlay hidden">
                <div class="image-loading-spinner"></div>
                <p>Analyzing Image...</p>
            </div>
            <img id="imageAnalysisUploadedImage" class="generated-image" src="" alt="Uploaded Image for Analysis" onerror="this.onerror=null;this.src='https://placehold.co/400x400/333333/FFFFFF?text=Image+Load+Error';" />
        </div>
        <p id="imageAnalysisResult" class="mt-4 text-left text-gray-200"></p>
        <p id="imageAnalysisStatus" class="mt-2 text-center text-yellow-400 text-xs"></p>
        <button class="full-screen-toggle-button" aria-label="Toggle Full Screen">⤢</button>
        <button class="modal-close-button close-feature-button" aria-label="Close Feature">&times;</button>
    </div>

    <!-- New Audio Transcription Content -->
    <div id="audioTranscriptionContent" class="ai-feature-content hidden">
        <h2 class="text-4xl font-bold mb-6 text-gray-100 leading-tight flex items-center justify-center gap-2">
            <img src="https://imelijah88.github.io/Avneed/logo.png" alt="Avneed AI Logo" class="h-8 w-auto object-contain filter-drop-shadow-neon-blue">
            Avneed Transcribe
        </h2>
        <div class="flex flex-col gap-4 mb-6">
            <div class="flex flex-row flex-wrap justify-center gap-4"> <!-- New wrapper div for buttons -->
                <label for="audioTranscriptionFileInput" class="ai-button flex-grow flex items-center justify-center cursor-pointer">Upload Audio File (.mp3, .wav)</label> <!-- Added flex-grow -->
                <input type="file" id="audioTranscriptionFileInput" accept=".mp3, .wav" class="hidden-file-input">
                <button id="transcribeAudioBtn" class="ai-button flex-grow" disabled>Transcribe Audio</button> <!-- Added flex-grow -->
            </div>
        </div>

        <div id="audioTranscriptionLoadingIndicator" class="mt-2 text-center hidden" aria-live="polite" aria-busy="true">
            <div class="loading-spinner"></div>
            <p class="ml-1 text-gray-300 inline-block">Transcribing...</p>
        </div>
        
        <textarea id="audioTranscriptionOutput" class="input-field w-full h-48 resize-none mt-4 text-left" placeholder="Transcription will appear here..." readonly aria-label="Audio Transcription Output"></textarea>
        <p id="audioTranscriptionStatus" class="mt-2 text-center text-yellow-400 text-xs"></p>
        <button class="full-screen-toggle-button" aria-label="Toggle Full Screen">⤢</button>
        <button class="modal-close-button close-feature-button" aria-label="Close Feature">&times;</button>
    </div>

    <div id="threeDViewerContent" class="ai-feature-content hidden">
        <h2 class="text-4xl font-bold mb-6 text-gray-100 leading-tight flex items-center justify-center gap-2">
            <img src="https://imelijah88.github.io/Avneed/logo.png" alt="Avneed AI Logo" class="h-8 w-auto object-contain filter-drop-shadow-neon-blue">
            Avneed 3D
        </h2>
        <div id="modalModelContainer" class="model-viewer-container mx-auto">
            <canvas id="modalModelCanvas" class="model-viewer-canvas"></canvas>
            <div id="modalModelStatus" class="model-status hidden" aria-live="polite">
                <div class="loading-spinner mb-4"></div>
                <p>Loading 3D Model...</p>
            </div>
            <label for="modalModelFileInput" id="modalModelFileInputLabel" class="model-file-input-label">+</label>
            <input type="file" id="modalModelFileInput" accept=".gltf, .glb" class="hidden-file-input">
            <input type="file" id="modalAudioFileInput" accept=".mp3" class="hidden-file-input">

            <div id="modalUploadMenu" class="upload-menu hidden" role="menu" aria-labelledby="modalModelFileInputLabel">
                <button class="upload-menu-button" data-type="model" role="menuitem">Upload 3D Model</button>
                <button class="upload-menu-button" data-type="audio" role="menuitem">Upload MP3</button>
            </div>

            <div id="modalAudioControls" class="audio-controls hidden">
                <button class="audio-play-pause-button" data-action="play-pause" aria-label="Play/Pause Model Audio">▶</button>
                <!-- New plus sign button for uploading audio -->
                <button class="audio-add-button" data-action="add-audio" aria-label="Add Audio File">+</button>
            </div>
            <audio id="modalPrimaryAudioPlayer" class="hidden"></audio>

            <div id="modalResizeHandle" class="resize-handle" aria-label="Resize 3D Viewer"></div>
            <div id="modalModelControls" class="model-controls hidden">
                <div class="grid grid-cols-3 gap-1">
                    <div></div>
                    <button class="model-control-button" data-action="move-up" aria-label="Move Model Up">↑</button>
                    <div></div>
                    <button class="model-control-button" data-action="move-left" aria-label="Move Model Left">←</button>
                    <button class="model-control-button" data-action="move-down" aria-label="Move Model Down">↓</button>
                    <button class="model-control-button" data-action="move-right" aria-label="Move Model Right">→</button>
                </div>
                <div class="grid grid-cols-2 gap-1">
                    <button class="model-control-button toggle-lock" data-action="toggle-lock" aria-label="Toggle Camera Lock">Lock Cam</button>
                    <button class="model-control-button" data-action="reset-view" aria-label="Reset View">Reset</button>
                    <button class="model-control-button" data-action="toggle-rotation" aria-label="Toggle Auto Rotation">Auto-Rotate</button>
                    <button class="model-control-button" data-action="toggle-background" aria-label="Toggle Background">Toggle BG</button>
                    <button class="model-control-button" data-action="toggle-wireframe" aria-label="Toggle Wireframe">Wireframe</button>
                    <button class="model-control-button" data-action="screenshot" aria-label="Take Screenshot">Screenshot</button>
                    <button class="model-control-button" data-action="scale-up" aria-label="Scale Up">Scale +</button>
                    <button class="model-control-button" data-action="scale-down" aria-label="Scale Down">Scale -</button>
                </div>
            </div>
        </div>
        <button class="full-screen-toggle-button" aria-label="Toggle Full Screen">⤢</button>
        <button class="modal-close-button close-feature-button" aria-label="Close Feature">&times;</button>
    </div>


    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithCustomToken, signInWithPopup, GithubAuthProvider, GoogleAuthProvider, signInAnonymously, signOut, onAuthStateChanged, fetchSignInMethodsForEmail, linkWithCredential } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase App ID (replace with your actual app ID if different)
        const appId = 'avneed-github-pages'; 

        // Firebase Configuration (replace with your actual Firebase project config)
        const firebaseConfig = {
            apiKey: "AIzaSyCda21nbBWaYKe4K_YndLmz06FdTv7b-Hk",
            authDomain: "avneed.firebaseapp.com",
            projectId: "avneed",
            storageBucket: "avneed.firebasestorage.app",
            messagingSenderId: "862015532884",
            appId: "1:862015532884:web:3c1731e57a678d0d3322c1",
            measurementId: "G-N31V5YXL47"
        };
        // Initial Auth Token (provided by Canvas environment, or null for anonymous sign-in)
        const initialAuthToken = null; 

        // Gemini API Key (replace with your actual Gemini API key)
        const GEMINI_API_KEY = "AIzaSyCGGbogRbxQQg7p_2SYhT-U6APOJKnq-3M"; 

        let app;
        let db;
        let auth;
        let userId = null; // Stores the current user's ID

        let modalViewerInstance = null; // Instance for the 3D viewer
        let unsubscribeProjectNotes = null; // Firestore unsubscribe function for project notes

        // Global background music player instance
        let backgroundMusicPlayer = null;
        let isBackgroundMusicPlaying = false; // To track state for play/pause button

        // Utility function to disable Firebase-related features and log a warning
        function disableFirebaseFeatures(message) {
            console.warn("Firebase features disabled:", message);
            // Optionally update UI elements to reflect disabled state
        }

        // Utility function to append messages to the chatbot history
        function appendChatMessage(chatHistoryDiv, text, sender) {
            const p = document.createElement('p');
            p.classList.add(`${sender}-message`);
            p.textContent = text;
            chatHistoryDiv.appendChild(p);
            chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight; // Auto-scroll to latest message
        }

        // Utility function to display temporary status messages
        function showStatusMessage(statusElement, message, type = 'info', duration = 3000) {
            if (!statusElement) return;
            statusElement.textContent = message;
            statusElement.className = 'mt-2 text-center text-xs'; // Reset classes
            if (type === 'success') {
                statusElement.classList.add('text-green-400');
            } else if (type === 'error') {
                statusElement.classList.add('text-red-400');
            } else {
                statusElement.classList.add('text-yellow-400');
            }
            // Clear message after a duration
            setTimeout(() => {
                statusElement.textContent = '';
                statusElement.className = 'mt-2 text-center text-yellow-400 text-xs'; // Reset to default status style
            }, duration);
        }

        // Initialize Firebase when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', async () => {
            // Check if firebaseConfig is valid before initializing
            if (Object.keys(firebaseConfig).length > 0 && firebaseConfig.projectId) {
                try {
                    app = initializeApp(firebaseConfig); // Initialize Firebase app
                    db = getFirestore(app); // Get Firestore instance
                    auth = getAuth(app); // Get Auth instance

                    if (auth) {
                        // Attempt to sign in with custom token (for Canvas) or anonymously
                        if (initialAuthToken) {
                             try {
                                await signInWithCustomToken(auth, initialAuthToken);
                                console.log("Signed in with custom token (Canvas environment).");
                            } catch (error) {
                                console.error("Error signing in with custom token:", error);
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously after custom token failure.");
                            }
                        } else {
                            try {
                                await signInAnonymously(auth);
                                console.log("Signed in anonymously (no custom token).");
                            } catch (error) {
                                console.error("Error signing in anonymously:", error);
                            }
                        }

                        // Listen for authentication state changes
                        onAuthStateChanged(auth, (user) => {
                            if (user) {
                                userId = user.uid; // Set userId if logged in
                                console.log("User is logged in:", userId);
                                updateLoginStatusInSettingsMenu(true, user); // Update UI
                            } else {
                                userId = null; // Clear userId if logged out
                                console.log("User is logged out.");
                                updateLoginStatusInSettingsMenu(false, null); // Update UI
                            }
                        });
                    } else {
                        console.error("Firebase Auth could not be initialized. Check your Firebase configuration.");
                        disableFirebaseFeatures('Firebase initialization failed. Check console for details.');
                    }
                } catch (firebaseInitError) {
                    console.error("Error initializing Firebase app:", firebaseInitError);
                    disableFirebaseFeatures('Firebase initialization failed. Check console for details.');
                }
            } else {
                console.warn("Firebase config not found or incomplete. Firebase features will be disabled. Please ensure firebaseConfig is correctly set in your script.");
                disableFirebaseFeatures('Firebase config not found. Features disabled. Please configure Firebase.');
            }

            // Initialize global background music player
            backgroundMusicPlayer = document.getElementById('backgroundMusicPlayer');
            const playPauseMusicBtn = document.getElementById('playPauseMusicBtn');
            const musicVolumeSlider = document.getElementById('musicVolumeSlider');

            if (backgroundMusicPlayer && playPauseMusicBtn && musicVolumeSlider) {
                // Set initial volume
                backgroundMusicPlayer.volume = parseFloat(musicVolumeSlider.value);

                // Play/Pause button functionality
                playPauseMusicBtn.addEventListener('click', () => {
                    if (backgroundMusicPlayer.paused) {
                        backgroundMusicPlayer.play()
                            .then(() => {
                                playPauseMusicBtn.textContent = '⏸';
                                isBackgroundMusicPlaying = true;
                                console.log("Background music playing.");
                            })
                            .catch(error => {
                                console.error("Error playing background music:", error);
                                // Most common error is Autoplay Policy, inform user
                                showStatusMessage(document.getElementById('settingsMenu').querySelector('.account-section') || settingsMenu, 'Browser blocked autoplay. Please click play again.', 'error', 5000);
                            });
                    } else {
                        backgroundMusicPlayer.pause();
                        playPauseMusicBtn.textContent = '▶';
                        isBackgroundMusicPlaying = false;
                        console.log("Background music paused.");
                    }
                });

                // Volume slider functionality
                musicVolumeSlider.addEventListener('input', () => {
                    backgroundMusicPlayer.volume = parseFloat(musicVolumeSlider.value);
                });

                // Handle browser autoplay policy: try to play on user interaction
                // (e.g., when clicking any button to open a modal)
                document.body.addEventListener('click', () => {
                    if (backgroundMusicPlayer.paused && !isBackgroundMusicPlaying) {
                        backgroundMusicPlayer.play().then(() => {
                            playPauseMusicBtn.textContent = '⏸';
                            isBackgroundMusicPlaying = true;
                        }).catch(error => {
                            // Still might be blocked, but we tried
                            console.warn("Autoplay still blocked on general click:", error);
                        });
                    }
                }, { once: true }); // Only try once on first click
            }
        });

        // Login modal elements (main AI features modal removed)
        const loginOptionsModal = document.getElementById('loginOptionsModal');
        const closeLoginModalBtn = document.getElementById('closeLoginModalBtn');
        const sectionHeader = document.getElementById('sectionHeader'); // Get reference to the header

        // Event listeners for closing login modal
        closeLoginModalBtn.addEventListener('click', closeLoginModal);
        loginOptionsModal.addEventListener('click', (e) => {
            if (e.target === loginOptionsModal) { // Close login modal only if clicking on the overlay
                closeLoginModal();
            }
        });

        // New feature display area
        const featureDisplayArea = document.getElementById('featureDisplayArea');
        let activeFeatureId = null; // To keep track of the currently displayed feature

        // Function to show a specific AI feature content directly on the page
        function showFeatureContent(featureId) {
            // Clear previous content
            featureDisplayArea.innerHTML = '';
            
            const templateContent = document.getElementById(featureId);
            if (!templateContent) {
                console.error(`Feature content with ID '${featureId}' not found.`);
                return;
            }
            
            // Clone the hidden feature content and append it to the display area
            const clonedContent = templateContent.cloneNode(true);
            clonedContent.classList.remove('hidden'); // Make it visible
            clonedContent.id = `active-${featureId}`; // Give it a unique ID when active

            featureDisplayArea.appendChild(clonedContent);
            activeFeatureId = featureId; // Set the active feature

            // Add expanded-header class to sectionHeader
            sectionHeader.classList.add('expanded-header');
            // Re-initialize floating balls to adjust to the new, larger container size
            initFloatingBalls();


            // Add full screen toggle button listener
            const fullScreenToggleBtn = clonedContent.querySelector('.full-screen-toggle-button');
            if (fullScreenToggleBtn) {
                // Ensure the full screen toggle button is visible when a feature is opened
                fullScreenToggleBtn.classList.remove('hidden');
                fullScreenToggleBtn.addEventListener('click', toggleFullScreen);
            }

            // Add close feature button listener
            const closeFeatureBtn = clonedContent.querySelector('.close-feature-button');
            if (closeFeatureBtn) {
                closeFeatureBtn.addEventListener('click', closeFeatureContent);
            }

            // Initialize specific feature's JavaScript logic
            if (featureId === 'projectNotesContent') {
                initProjectNotesFeature();
            } else if (featureId === 'chatbotContent') {
                initChatbotFeature();
            } else if (featureId === 'imageGeneratorContent') {
                initImageGeneratorFeature();
            } else if (featureId === 'imageAnalysisContent') {
                initImageAnalysisFeature();
            } else if (featureId === 'audioTranscriptionContent') {
                initAudioTranscriptionFeature();
            } else if (featureId === 'threeDViewerContent') {
                init3DViewerFeature();
                // Pause background music when 3D viewer is active and has its own audio
                if (backgroundMusicPlayer && !backgroundMusicPlayer.paused) {
                    backgroundMusicPlayer.pause();
                    isBackgroundMusicPlaying = true; // Keep track that it was playing
                }
            }
        }

        // Function to close the currently displayed AI feature content
        function closeFeatureContent() {
            // Ensure simulated fullscreen is exited if active
            if (document.body.classList.contains('simulated-fullscreen-active')) {
                document.body.classList.remove('simulated-fullscreen-active');
            }

            featureDisplayArea.innerHTML = ''; // Clear the feature display area
            activeFeatureId = null; // Reset active feature
            sectionHeader.classList.remove('expanded-header'); // Shrink header back
            // Re-initialize floating balls to adjust to the original container size
            initFloatingBalls();

            // Resume background music if it was playing before the 3D viewer was active
            if (backgroundMusicPlayer && isBackgroundMusicPlaying) {
                backgroundMusicPlayer.play().catch(e => console.error("Error resuming background music:", e));
                document.getElementById('playPauseMusicBtn').textContent = '⏸'; // Update main page button
            }
        }

        // Function to toggle simulated full screen mode
        function toggleFullScreen() {
            const activeFeatureContent = featureDisplayArea.querySelector('.ai-feature-content:not(.hidden)');
            if (!activeFeatureContent) {
                console.warn("No active feature content to make fullscreen.");
                return;
            }

            const fullScreenToggleBtn = activeFeatureContent.querySelector('.full-screen-toggle-button');

            if (document.body.classList.contains('simulated-fullscreen-active')) {
                // Exit simulated fullscreen
                document.body.classList.remove('simulated-fullscreen-active');
                if (fullScreenToggleBtn) {
                    fullScreenToggleBtn.classList.remove('hidden'); // Show the fullscreen button
                }
                // When exiting fullscreen, the header should return to its expanded state
                // and balls should restart animation within that header.
                sectionHeader.classList.add('expanded-header'); // Ensure header is expanded
                initFloatingBalls(); // Re-initialize balls for the header
            } else {
                // Enter simulated fullscreen
                document.body.classList.add('simulated-fullscreen-active');
                if (fullScreenToggleBtn) {
                    fullScreenToggleBtn.classList.add('hidden'); // Hide the fullscreen button
                }
                // When entering fullscreen, the header is hidden by CSS, so balls are not visible.
            }
        }


        // Removed the native fullscreenchange event listener as we are using simulated fullscreen.


        // Function to open the login options modal
        function openLoginModal() {
            loginOptionsModal.classList.add('visible'); // Show login modal
            document.body.style.overflow = 'hidden'; // Prevent body scrolling
            initLoginOptionsModal(); // Initialize login modal logic
        }

        // Function to close the login options modal
        function closeLoginModal() {
            loginOptionsModal.classList.remove('visible'); // Hide login modal
            document.body.style.overflow = ''; // Re-enable body scrolling
        }

        // --- Project Notes Feature Logic ---
        function initProjectNotesFeature() {
            const userNotesInput = document.getElementById('modalUserNotesInput');
            const saveNotesBtn = document.getElementById('modalSaveNotesBtn');
            const userNotesStatus = document.getElementById('modalUserNotesStatus');
            const notesFileInput = document.getElementById('notesFileInput');

            // Set placeholders/initial text
            if (userNotesInput) userNotesInput.placeholder = 'Type your private project notes here...';
            if (saveNotesBtn) saveNotesBtn.textContent = 'Save Project Notes';
            if (userNotesStatus) userNotesStatus.textContent = 'Please log in to save notes.';

            // Add event listener for saving notes
            if (saveNotesBtn) saveNotesBtn.addEventListener('click', saveProjectNotesInModal);

            // Auto-resize textarea on input
            if (userNotesInput) {
                userNotesInput.addEventListener('input', () => {
                    userNotesInput.style.height = 'auto';
                    userNotesInput.style.height = (userNotesInput.scrollHeight) + 'px';
                    userNotesInput.style.overflowY = userNotesInput.scrollHeight > userNotesInput.clientHeight ? 'auto' : 'hidden';
                });
            }

            // Handle file input for notes
            if (notesFileInput) {
                notesFileInput.addEventListener('change', async (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        if (file.type !== 'text/plain') {
                            showStatusMessage(userNotesStatus, 'Please upload a plain text (.txt) file.', 'error');
                            return;
                        }
                        showStatusMessage(userNotesStatus, 'Reading file...', 'info');
                        try {
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                userNotesInput.value = e.target.result;
                                userNotesInput.style.height = 'auto';
                                userNotesInput.style.height = (userNotesInput.scrollHeight) + 'px';
                                showStatusMessage(userNotesStatus, 'Notes loaded from file!', 'success');
                                saveProjectNotesInModal(); // Auto-save after loading
                            };
                            reader.onerror = (e) => {
                                showStatusMessage(userNotesStatus, `Error reading file: ${e.target.error.name}`, 'error');
                                console.error('File reading error:', e.target.error);
                            };
                            reader.readAsText(file);
                        } catch (error) {
                            showStatusMessage(userNotesStatus, `Error processing file: ${error.message}`, 'error');
                            console.error('File processing error:', error);
                        }
                    }
                });
            }

            // Enable/disable features based on login status
            if (userId) {
                userNotesInput.disabled = false;
                saveNotesBtn.disabled = false;
                loadProjectNotesInModal(); // Load notes if logged in
            } else {
                userNotesInput.disabled = true;
                saveNotesBtn.disabled = true;
                userNotesStatus.textContent = 'Please log in to save notes.';
            }
        }

        // Function to save project notes to Firestore
        async function saveProjectNotesInModal() {
            const userNotesInput = document.getElementById('modalUserNotesInput');
            const userNotesStatus = document.getElementById('modalUserNotesStatus');

            if (!userId) { showStatusMessage(userNotesStatus, 'Please log in to save notes.', 'error'); return; }
            if (!db) { showStatusMessage(userNotesStatus, 'Firebase not initialized. Cannot save notes.', 'error'); return; }

            const projectNotes = userNotesInput.value;
            // Define Firestore document reference for private user notes
            const userDocRef = doc(db, 'artifacts', appId, 'users', userId, 'private', 'my-project-notes');

            try {
                await setDoc(userDocRef, { content: projectNotes, timestamp: new Date() }, { merge: true }); // Save/update document
                showStatusMessage(userNotesStatus, 'Project notes saved successfully!', 'success');
                console.log("User project notes saved.");
            } catch (error) {
                console.error("Error saving project notes:", error);
                showStatusMessage(userNotesStatus, `Error saving project notes: ${error.message}`, 'error');
            }
        }

        // Function to load project notes from Firestore
        function loadProjectNotesInModal() {
            const userNotesInput = document.getElementById('modalUserNotesInput');
            const userNotesStatus = document.getElementById('modalUserNotesStatus');

            if (unsubscribeProjectNotes) { // Clear previous listener if any
                unsubscribeProjectNotes();
            }

            if (!userId || !db) { showStatusMessage(userNotesStatus, 'Please log in to save notes.', 'error'); return; }

            const userDocRef = doc(db, 'artifacts', appId, 'users', userId, 'private', 'my-project-notes');

            // Listen for real-time updates to the document
            unsubscribeProjectNotes = onSnapshot(userDocRef, (docSnap) => {
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    if (userNotesInput) userNotesInput.value = data.content || '';
                    if (userNotesStatus) userNotesStatus.textContent = 'Project notes loaded.';
                } else {
                    if (userNotesInput) userNotesInput.value = '';
                    if (userNotesStatus) userNotesStatus.textContent = 'No project notes found. Start typing!';
                }
                console.log("User project notes loaded/updated from Firestore.");
            }, (error) => {
                console.error("Error loading project notes:", error);
                showStatusMessage(userNotesStatus, `Error loading project notes: ${error.message}`, 'error');
            });
        }

        // --- Authentication & Settings Menu Logic ---
        // Updates the login/logout status and displays user ID in the settings menu
        function updateLoginStatusInSettingsMenu(isLoggedIn, user) {
            const loginLogoutContainer = document.getElementById('loginLogoutContainer');
            if (!loginLogoutContainer) return;

            loginLogoutContainer.innerHTML = ''; // Clear existing content

            if (isLoggedIn) {
                const displayId = user.isAnonymous ? 'Guest User' : user.uid;
                loginLogoutContainer.innerHTML = `
                    <div class="account-section">
                        <p class="text-xs text-gray-400 truncate text-center mb-2">Logged in as: ${displayId.length > 20 ? displayId.substring(0, 10) + '...' + displayId.substring(displayId.length - 10) : displayId}</p>
                        <div class="flex gap-2">
                            <button id="settingsCopyUserIdBtn" class="ai-button text-xs px-2 py-1 flex-grow">Copy ID</button>
                            <button id="settingsLogoutBtn" class="ai-button text-xs px-2 py-1 flex-grow">Log Out</button>
                        </div>
                    </div>
                `;
                // Add event listeners for copy and logout buttons
                document.getElementById('settingsCopyUserIdBtn').addEventListener('click', copyUserIdToClipboardInSettingsMenu);
                document.getElementById('settingsLogoutBtn').addEventListener('click', async () => {
                    if (!auth) { showStatusMessage(document.getElementById('modalLoginStatus'), 'Firebase not initialized. Cannot log out.', 'error'); return; }
                    try { await signOut(auth); console.log("User signed out."); }
                    catch (error) { console.error("Error signing out:", error); showStatusMessage(document.getElementById('modalLoginStatus'), `Logout failed: ${error.message}`, 'error'); }
                });
            } else {
                loginLogoutContainer.innerHTML = `
                    <button id="settingsLoginBtn" class="settings-menu-button" role="menuitem">Log In</button>
                `;
                document.getElementById('settingsLoginBtn').addEventListener('click', openLoginModal); // Open login modal
            }
        }

        // Copies the current user's ID to the clipboard
        function copyUserIdToClipboardInSettingsMenu() {
            const userIdText = auth.currentUser?.uid;
            const copyButton = document.getElementById('settingsCopyUserIdBtn');
            if (userIdText && copyButton) {
                const tempInput = document.createElement('textarea'); // Use a temporary textarea for copying
                tempInput.value = userIdText;
                document.body.appendChild(tempInput);
                tempInput.select();
                try {
                    document.execCommand('copy'); // Execute copy command
                    copyButton.textContent = 'Copied!';
                    setTimeout(() => { copyButton.textContent = 'Copy ID'; }, 2000); // Reset button text
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    copyButton.textContent = 'Failed to copy!';
                }
                document.body.removeChild(tempInput); // Clean up temporary textarea
            }
        }

        // Initializes the login options modal with Google, GitHub, and Guest sign-in
        function initLoginOptionsModal() {
            const modalLoginBtnGoogle = document.getElementById('modalLoginBtnGoogle');
            const modalLoginBtnGithub = document.getElementById('modalLoginBtnGithub');
            const modalLoginBtnGuest = document.getElementById('modalLoginBtnGuest');
            const modalLoginStatus = document.getElementById('modalLoginStatus');

            // Google Sign-in
            if (modalLoginBtnGoogle) modalLoginBtnGoogle.addEventListener('click', async () => {
                if (!auth) { showStatusMessage(modalLoginStatus, 'Firebase not initialized. Cannot log in.', 'error'); return; }
                const provider = new GoogleAuthProvider();
                try { 
                    await signInWithPopup(auth, provider); 
                    console.log("Signed in with Google!"); 
                    closeLoginModal();
                }
                catch (error) { 
                    console.error("Error signing in with Google:", error); 
                    if (error.code === 'auth/account-exists-with-different-credential') {
                        const pendingCred = error.credential;
                        const email = error.email;
                        try {
                            const methods = await fetchSignInMethodsForEmail(auth, email);
                            const firstMethod = methods[0];
                            if (auth.currentUser) { // If user is already logged in with another provider, link accounts
                                await linkWithCredential(auth.currentUser, pendingCred);
                                showStatusMessage(modalLoginStatus, `Account linked successfully!`, 'success');
                                console.log("Account linked with Google!");
                                closeLoginModal();
                            } else { // If not logged in, prompt to sign in with existing method
                                showStatusMessage(modalLoginStatus, `Account with ${email} already exists. Please sign in with ${firstMethod} first.`, 'error');
                            }
                        } catch (linkError) {
                            console.error("Error linking account:", linkError);
                            showStatusMessage(modalLoginStatus, `Error linking account: ${linkError.message}`, 'error');
                        }
                    } else {
                        showStatusMessage(modalLoginStatus, `Google login failed: ${error.message}`, 'error'); 
                    }
                }
            });
            // GitHub Sign-in
            if (modalLoginBtnGithub) modalLoginBtnGithub.addEventListener('click', async () => {
                if (!auth) { showStatusMessage(modalLoginStatus, 'Firebase not initialized. Cannot log in.', 'error'); return; }
                const provider = new GithubAuthProvider();
                try { 
                    await signInWithPopup(auth, provider); 
                    console.log("Signed in with GitHub!"); 
                    closeLoginModal();
                }
                catch (error) { 
                    console.error("Error signing in with GitHub:", error); 
                    if (error.code === 'auth/account-exists-with-different-credential') {
                        const pendingCred = error.credential;
                        const email = error.email;
                        try {
                            const methods = await fetchSignInMethodsForEmail(auth, email);
                            const firstMethod = methods[0];
                            if (auth.currentUser) { // If user is already logged in with another provider, link accounts
                                await linkWithCredential(auth.currentUser, pendingCred);
                                showStatusMessage(modalLoginStatus, `Account linked successfully!`, 'success');
                                console.log("Account linked with GitHub!");
                                closeLoginModal();
                            } else { // If not logged in, prompt to sign in with existing method
                                showStatusMessage(modalLoginStatus, `Account with ${email} already exists. Please sign in with ${firstMethod} first.`, 'error');
                            }
                        } catch (linkError) {
                            console.error("Error linking account:", linkError);
                            showStatusMessage(modalLoginStatus, `Error linking account: ${linkError.message}`, 'error');
                        }
                    } else {
                        showStatusMessage(modalLoginStatus, `GitHub login failed: ${error.message}`, 'error'); 
                    }
                }
            });
            // Anonymous (Guest) Sign-in
            if (modalLoginBtnGuest) modalLoginBtnGuest.addEventListener('click', async () => {
                if (!auth) { showStatusMessage(modalLoginStatus, 'Firebase not initialized. Cannot log in.', 'error'); return; }
                try { 
                    await signInAnonymously(auth); 
                    console.log("Signed in as Guest!"); 
                    closeLoginModal();
                }
                catch (error) { 
                    console.error("Error signing in anonymously:", error); 
                    showStatusMessage(modalLoginStatus, `Guest login failed: ${error.message}`, 'error'); 
                }
            });
        }

        // --- Chatbot Feature Logic (Enhanced for Document & Personas) ---
        function initChatbotFeature() {
            const chatHistoryDiv = document.getElementById('chatbotHistory');
            const sendBtn = document.getElementById('chatbotSendBtn');
            const loadingIndicator = document.getElementById('chatbotLoadingIndicator');
            const chatStatus = document.getElementById('chatbotStatus');
            const chatbotDocumentFileInput = document.getElementById('chatbotDocumentFileInput');
            const aiInputText = document.getElementById('chatbotInputText');
            const aiPersonaSelect = document.getElementById('aiPersonaSelect');

            chatHistoryDiv.innerHTML = `<p class="ai-message">Hello! How can I assist?</p>`;
            let chatHistory = []; // Stores the conversation history for the AI
            let uploadedDocumentContent = null; // Stores content of uploaded document

            // Set placeholders/initial text
            if (aiInputText) aiInputText.placeholder = 'Type message or ask about the uploaded document...';
            if (sendBtn) sendBtn.textContent = 'Send';
            if (loadingIndicator) loadingIndicator.querySelector('p').textContent = 'Thinking...';

            // Auto-resize textarea on input
            if (aiInputText) {
                aiInputText.addEventListener('input', () => {
                    aiInputText.style.height = 'auto';
                    aiInputText.style.height = (aiInputText.scrollHeight) + 'px';
                    aiInputText.style.overflowY = aiInputText.scrollHeight > aiInputText.clientHeight ? 'auto' : 'hidden';
                });
            }

            // Function to send message to Gemini API
            async function sendMessage(prompt, fileContent = null) {
                // Determine the AI persona and add a system instruction
                let personaInstruction = "";
                const selectedPersona = aiPersonaSelect.value;
                if (selectedPersona === "therapist") {
                    personaInstruction = "You are a compassionate and empathetic therapist. Respond with supportive and guiding language.";
                } else if (selectedPersona === "business-consultant") {
                    personaInstruction = "You are a sharp and strategic business consultant. Provide actionable insights and professional advice.";
                } else if (selectedPersona === "study-buddy") {
                    personaInstruction = "You are a helpful and clear study buddy. Explain concepts simply and provide learning tips.";
                } else if (selectedPersona === "creativity-coach") {
                    personaInstruction = "You are an inspiring creativity coach. Encourage innovative thinking and provide prompts for creative writing/ideas.";
                } else if (selectedPersona === "fun-mode") {
                    personaInstruction = "You are in fun mode! Respond with jokes, stories, or engage in playful role-playing.";
                }

                // Append user message to chat history display
                appendChatMessage(chatHistoryDiv, prompt, 'user');

                let userParts = [{ text: prompt }];
                if (fileContent) {
                    userParts.push({ text: `\n\n--- Document Content ---\n${fileContent}\n--- End Document Content ---` });
                }
                
                // Add persona instruction to the first turn if not already present
                if (chatHistory.length === 0 && personaInstruction) {
                    chatHistory.push({ role: "user", parts: [{ text: personaInstruction + "\n\n" + prompt }] });
                } else {
                    chatHistory.push({ role: "user", parts: userParts });
                }

                aiInputText.value = ''; // Clear input
                aiInputText.style.height = 'auto'; // Reset textarea height
                sendBtn.disabled = true; // Disable send button
                aiInputText.disabled = true; // Disable input
                chatbotDocumentFileInput.disabled = true; // Disable file input
                loadingIndicator.classList.remove('hidden'); // Show loading indicator
                chatStatus.textContent = ''; // Clear status message

                try {
                    const payload = { contents: chatHistory };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        appendChatMessage(chatHistoryDiv, aiResponseText, 'ai'); // Append AI response
                        chatHistory.push({ role: "model", parts: [{ text: aiResponseText }] }); // Add to history
                    } else {
                        appendChatMessage(chatHistoryDiv, "Sorry, I couldn't generate a response. Please try again.", 'ai');
                        console.error('API response structure unexpected:', result);
                    }
                } catch (error) {
                    appendChatMessage(chatHistoryDiv, "An error occurred while connecting to the AI. Please check your internet connection or try again later.", 'ai');
                    chatStatus.textContent = `Error: ${error.message}`;
                    console.error('Error during API call:', error);
                } finally {
                    sendBtn.disabled = false; // Re-enable send button
                    aiInputText.disabled = false; // Re-enable input
                    chatbotDocumentFileInput.disabled = false; // Re-enable file input
                    loadingIndicator.classList.add('hidden'); // Hide loading indicator
                }
            }

            // Send button click listener
            sendBtn.addEventListener('click', () => {
                const prompt = aiInputText.value.trim();
                if (prompt || uploadedDocumentContent) { // Allow sending if there's text or uploaded content
                    sendMessage(prompt, uploadedDocumentContent);
                    uploadedDocumentContent = null; // Clear document content after sending
                    chatbotDocumentFileInput.value = ''; // Clear file input
                } else {
                    showStatusMessage(chatStatus, 'Please enter a message or upload a document.', 'error');
                }
            });

            // Enter key listener for text input
            aiInputText.addEventListener('keypress', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) { // Send on Enter, new line on Shift+Enter
                    event.preventDefault();
                    sendBtn.click();
                }
            });

            // Document file input listener
            chatbotDocumentFileInput.addEventListener('change', async (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (file.type !== 'text/plain') {
                        showStatusMessage(chatStatus, 'Please upload a plain text (.txt) file for document analysis.', 'error');
                        return;
                    }
                    showStatusMessage(chatStatus, 'Reading document...', 'info');
                    try {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            uploadedDocumentContent = e.target.result; // Store content
                            showStatusMessage(chatStatus, `Document '${file.name}' loaded. Ask your question!`, 'success');
                            aiInputText.placeholder = `Ask a question about '${file.name}' or type a new message...`;
                        };
                        reader.onerror = (e) => {
                            showStatusMessage(chatStatus, `Error reading file: ${e.target.error.name}`, 'error');
                            console.error('File reading error:', e.target.error);
                        };
                        reader.readAsText(file);
                    } catch (error) {
                        showStatusMessage(chatStatus, `Error processing file: ${error.message}`, 'error');
                        console.error('File processing error:', error);
                    }
                }
            });
        }

        // --- Image Generator Feature Logic ---
        function initImageGeneratorFeature() {
            const imageGenPromptInput = document.getElementById('imageGenPromptInput');
            const imageGenGenerateBtn = document.getElementById('imageGenGenerateBtn');
            const imageGenDisplayArea = document.getElementById('imageGenDisplayArea');
            const imageGenGeneratedImage = document.getElementById('imageGenGeneratedImage');
            const imageGenLoadingOverlay = document.getElementById('imageGenLoadingOverlay');
            const imageGenStatus = document.getElementById('imageGenStatus');
            const imageGenAspectRatioSelect = document.getElementById('imageGenAspectRatio');

            // Set placeholders/initial text
            if (imageGenPromptInput) imageGenPromptInput.placeholder = 'Describe the image you want to generate...';
            if (imageGenGenerateBtn) imageGenGenerateBtn.textContent = 'Generate Image';

            // Auto-resize textarea on input
            if (imageGenPromptInput) {
                imageGenPromptInput.addEventListener('input', () => {
                    imageGenPromptInput.style.height = 'auto';
                    imageGenPromptInput.style.height = (imageGenPromptInput.scrollHeight) + 'px';
                    imageGenPromptInput.style.overflowY = imageGenPromptInput.scrollHeight > imageGenPromptInput.clientHeight ? 'auto' : 'hidden';
                });
            }

            // Generate button click listener
            imageGenGenerateBtn.addEventListener('click', async () => {
                const prompt = imageGenPromptInput.value.trim();
                const aspectRatio = imageGenAspectRatioSelect.value;

                if (!prompt) {
                    showStatusMessage(imageGenStatus, 'Please enter a prompt for the image.', 'error');
                    imageGenDisplayArea.classList.add('hidden'); // Hide display area if no prompt
                    return;
                }

                imageGenDisplayArea.classList.remove('hidden'); // Show display area
                imageGenLoadingOverlay.classList.remove('hidden'); // Show loading overlay
                imageGenStatus.textContent = 'Generating image... This may take a moment.';
                imageGenGeneratedImage.src = ''; // Clear previous image
                imageGenGeneratedImage.alt = 'Generating...';

                // Apply aspect ratio class to the container
                imageGenDisplayArea.classList.remove('aspect-1-1', 'aspect-16-9', 'aspect-4-3', 'aspect-9-16');
                imageGenDisplayArea.classList.add(`aspect-${aspectRatio}`);

                try {
                    const payload = { instances: { prompt: prompt }, parameters: { "sampleCount": 1 } };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${GEMINI_API_KEY}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.predictions && result.predictions.length > 0 && result.predictions[0].bytesBase64Encoded) {
                        const imageUrl = `data:image/png;base64,${result.predictions[0].bytesBase64Encoded}`;
                        imageGenGeneratedImage.src = imageUrl;
                        imageGenGeneratedImage.alt = `Generated image for prompt: ${prompt}`;
                        showStatusMessage(imageGenStatus, 'Image generated successfully!', 'success');
                    } else {
                        showStatusMessage(imageGenStatus, 'Failed to generate image. Please try a different prompt.', 'error');
                        console.error('Image generation response missing expected data:', result);
                    }
                } catch (error) {
                    showStatusMessage(imageGenStatus, `Error generating image: ${error.message}`, 'error');
                    console.error('Error during image generation API call:', error);
                } finally {
                    imageGenLoadingOverlay.classList.add('hidden'); // Hide loading overlay
                }
            });
        }

        // --- Image Analysis Feature Logic (New) ---
        function initImageAnalysisFeature() {
            const imageAnalysisFileInput = document.getElementById('imageAnalysisFileInput');
            const imageAnalysisPromptInput = document.getElementById('imageAnalysisPromptInput');
            const imageAnalysisAnalyzeBtn = document.getElementById('imageAnalysisAnalyzeBtn');
            const imageAnalysisDisplayArea = document.getElementById('imageAnalysisDisplayArea');
            const imageAnalysisUploadedImage = document.getElementById('imageAnalysisUploadedImage');
            const imageAnalysisLoadingOverlay = document.getElementById('imageAnalysisLoadingOverlay');
            const imageAnalysisResult = document.getElementById('imageAnalysisResult');
            const imageAnalysisStatus = document.getElementById('imageAnalysisStatus');

            let uploadedImageBase64 = null; // To store the base64 encoded image

            // Set initial states
            imageAnalysisAnalyzeBtn.disabled = true;
            imageAnalysisResult.textContent = '';
            imageAnalysisDisplayArea.classList.add('hidden');

            // Auto-resize textarea on input
            if (imageAnalysisPromptInput) {
                imageAnalysisPromptInput.addEventListener('input', () => {
                    imageAnalysisPromptInput.style.height = 'auto';
                    imageAnalysisPromptInput.style.height = (imageAnalysisPromptInput.scrollHeight) + 'px';
                    imageAnalysisPromptInput.style.overflowY = imageAnalysisPromptInput.scrollHeight > imageAnalysisPromptInput.clientHeight ? 'auto' : 'hidden';
                });
            }

            // Handle image file input
            imageAnalysisFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (!file.type.startsWith('image/')) {
                        showStatusMessage(imageAnalysisStatus, 'Please upload an image file.', 'error');
                        imageAnalysisAnalyzeBtn.disabled = true;
                        imageAnalysisDisplayArea.classList.add('hidden');
                        return;
                    }

                    const reader = new FileReader();
                    reader.onload = (e) => {
                        uploadedImageBase64 = e.target.result.split(',')[1]; // Get base64 part
                        imageAnalysisUploadedImage.src = e.target.result;
                        imageAnalysisUploadedImage.alt = 'Uploaded image';
                        imageAnalysisDisplayArea.classList.remove('hidden');
                        imageAnalysisAnalyzeBtn.disabled = false;
                        showStatusMessage(imageAnalysisStatus, 'Image uploaded. Click Analyze or ask a question!', 'success');
                        imageAnalysisResult.textContent = ''; // Clear previous result
                    };
                    reader.onerror = (e) => {
                        showStatusMessage(imageAnalysisStatus, `Error reading file: ${e.target.error.name}`, 'error');
                        console.error('File reading error:', e.target.error);
                        imageAnalysisAnalyzeBtn.disabled = true;
                        imageAnalysisDisplayArea.classList.add('hidden');
                    };
                    reader.readAsDataURL(file); // Read file as Data URL (base64)
                } else {
                    imageAnalysisAnalyzeBtn.disabled = true;
                    imageAnalysisDisplayArea.classList.add('hidden');
                    uploadedImageBase64 = null;
                }
            });

            // Analyze button click listener
            imageAnalysisAnalyzeBtn.addEventListener('click', async () => {
                if (!uploadedImageBase64) {
                    showStatusMessage(imageAnalysisStatus, 'Please upload an image first.', 'error');
                    return;
                }

                imageAnalysisLoadingOverlay.classList.remove('hidden');
                imageAnalysisResult.textContent = '';
                imageAnalysisStatus.textContent = 'Analyzing image...';
                imageAnalysisAnalyzeBtn.disabled = true;
                imageAnalysisFileInput.disabled = true;
                imageAnalysisPromptInput.disabled = true;

                const prompt = imageAnalysisPromptInput.value.trim() || "Describe this image."; // Default prompt

                try {
                    const chatHistory = [
                        {
                            role: "user",
                            parts: [
                                { text: prompt },
                                {
                                    inlineData: {
                                        mimeType: "image/png", // Assuming PNG, adjust if needed for other types
                                        data: uploadedImageBase64
                                    }
                                }
                            ]
                        }
                    ];

                    const payload = { contents: chatHistory };
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${GEMINI_API_KEY}`;

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const analysisText = result.candidates[0].content.parts[0].text;
                        imageAnalysisResult.textContent = analysisText;
                        showStatusMessage(imageAnalysisStatus, 'Image analysis complete!', 'success');
                    } else {
                        imageAnalysisResult.textContent = "Could not analyze image. Please try again.";
                        showStatusMessage(imageAnalysisStatus, 'Analysis failed.', 'error');
                        console.error('Image analysis response structure unexpected:', result);
                    }
                } catch (error) {
                    imageAnalysisResult.textContent = "An error occurred during analysis.";
                    showStatusMessage(imageAnalysisStatus, `Error: ${error.message}`, 'error');
                    console.error('Error during image analysis API call:', error);
                } finally {
                    imageAnalysisLoadingOverlay.classList.add('hidden');
                    imageAnalysisAnalyzeBtn.disabled = false;
                    imageAnalysisFileInput.disabled = false;
                    imageAnalysisPromptInput.disabled = false;
                }
            });
        }

        // --- Audio Transcription Feature Logic (New) ---
        function initAudioTranscriptionFeature() {
            const audioTranscriptionFileInput = document.getElementById('audioTranscriptionFileInput');
            const transcribeAudioBtn = document.getElementById('transcribeAudioBtn');
            const audioTranscriptionOutput = document.getElementById('audioTranscriptionOutput');
            const audioTranscriptionLoadingIndicator = document.getElementById('audioTranscriptionLoadingIndicator');
            const audioTranscriptionStatus = document.getElementById('audioTranscriptionStatus');

            let uploadedAudioFile = null; // To store the uploaded audio file

            // Set initial states
            transcribeAudioBtn.disabled = true;
            audioTranscriptionOutput.value = '';
            audioTranscriptionOutput.placeholder = "Transcription will appear here...";

            // Auto-resize textarea on input (though it's readonly, useful if content is set programmatically)
            if (audioTranscriptionOutput) {
                audioTranscriptionOutput.addEventListener('input', () => {
                    audioTranscriptionOutput.style.height = 'auto';
                    audioTranscriptionOutput.style.height = (audioTranscriptionOutput.scrollHeight) + 'px';
                    audioTranscriptionOutput.style.overflowY = audioTranscriptionOutput.scrollHeight > audioTranscriptionOutput.clientHeight ? 'auto' : 'hidden';
                });
            }

            // Handle audio file input
            audioTranscriptionFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    if (!file.type.startsWith('audio/')) {
                        showStatusMessage(audioTranscriptionStatus, 'Please upload an audio file (.mp3, .wav).', 'error');
                        transcribeAudioBtn.disabled = true;
                        audioTranscriptionOutput.value = '';
                        uploadedAudioFile = null;
                        return;
                    }
                    uploadedAudioFile = file;
                    transcribeAudioBtn.disabled = false;
                    audioTranscriptionOutput.value = ''; // Clear previous transcription
                    showStatusMessage(audioTranscriptionStatus, `Audio file '${file.name}' loaded. Click Transcribe Audio.`, 'success');
                } else {
                    transcribeAudioBtn.disabled = true;
                    audioTranscriptionOutput.value = '';
                    uploadedAudioFile = null;
                }
            });

            // Transcribe button click listener
            transcribeAudioBtn.addEventListener('click', async () => {
                if (!uploadedAudioFile) {
                    showStatusMessage(audioTranscriptionStatus, 'Please upload an audio file first.', 'error');
                    return;
                }

                audioTranscriptionLoadingIndicator.classList.remove('hidden');
                audioTranscriptionOutput.value = '';
                audioTranscriptionStatus.textContent = 'Transcribing audio... (This is a simulated transcription)';
                transcribeAudioBtn.disabled = true;
                audioTranscriptionFileInput.disabled = true;

                try {
                    // --- SIMULATED AUDIO TRANSCRIPTION ---
                    // In a real application, you would send the audio file to a Vertex AI Speech-to-Text API
                    // For example:
                    // const audioBase64 = await new Promise((resolve, reject) => {
                    //     const reader = new FileReader();
                    //     reader.onloadend = () => resolve(reader.result.split(',')[1]);
                    //     reader.onerror = reject;
                    //     reader.readAsDataURL(uploadedAudioFile);
                    // });
                    //
                    // const audioPayload = {
                    //     audioContent: audioBase66,
                    //     config: {
                    //         encoding: 'LINEAR16', // Or 'MP3', 'FLAC', etc. based on your audio
                    //         sampleRateHertz: 16000, // Adjust based on your audio
                    //         languageCode: 'en-US',
                    //     },
                    // };
                    //
                    // const transcriptionApiUrl = `YOUR_VERTEX_AI_SPEECH_TO_TEXT_API_ENDPOINT?key=${GEMINI_API_KEY}`;
                    // const response = await fetch(transcriptionApiUrl, {
                    //     method: 'POST',
                    //     headers: { 'Content-Type': 'application/json' },
                    //     body: JSON.stringify(audioPayload),
                    // });
                    // const result = await response.json();
                    // const transcribedText = result.results[0].alternatives[0].transcript;
                    // --- END SIMULATED AUDIO TRANSCRIPTION ---

                    // For demonstration, we'll use a placeholder text after a delay
                    await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate network delay

                    const transcribedText = `[Simulated Transcription of "${uploadedAudioFile.name}"]: This is a placeholder for the actual audio transcription. In a real application, a Vertex AI Speech-to-Text model would process the uploaded audio file and convert spoken words into text here. For example, if you uploaded a song, you might see lyrics. If it was a meeting, you'd see the dialogue. You can now copy this text and use it in the Avneed Chat for summarization or translation!`;
                    
                    audioTranscriptionOutput.value = transcribedText;
                    audioTranscriptionOutput.style.height = 'auto'; // Recalculate height
                    audioTranscriptionOutput.style.height = (audioTranscriptionOutput.scrollHeight) + 'px';
                    showStatusMessage(audioTranscriptionStatus, 'Transcription complete (simulated)!', 'success');

                } catch (error) {
                    audioTranscriptionOutput.value = "Error during transcription.";
                    showStatusMessage(audioTranscriptionStatus, `Error: ${error.message}`, 'error');
                    console.error('Error during audio transcription:', error);
                } finally {
                    audioTranscriptionLoadingIndicator.classList.add('hidden');
                    transcribeAudioBtn.disabled = false;
                    audioTranscriptionFileInput.disabled = false;
                }
            });
        }

        // --- 3D Viewer Feature Logic ---
        function init3DViewerInstance(canvas, container, statusElement, audioPlayerElement, audioControlsElement) {
            const scene = new THREE.Scene();
            scene.background = null; // Transparent background by default

            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(0, 0, 5); // Initial camera position

            const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearAlpha(0); // Ensure renderer background is transparent

            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; // Smooth camera movement
            controls.dampingFactor = 0.25;
            controls.screenSpacePanning = false;
            controls.maxPolarAngle = Math.PI / 2; // Prevent camera from going below ground

            // Add lights to the scene
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.8);
            directionalLight.position.set(0, 5, 5).normalize();
            scene.add(directionalLight);

            const pointLight = new THREE.PointLight(0x00FFFF, 2.0, 100); // Neon blue point light
            pointLight.position.set(2, 2, 2);
            scene.add(pointLight);

            statusElement.classList.remove('hidden');
            statusElement.innerHTML = `<p>Upload a 3D model (.gltf, .glb)</p><p>Use mouse to interact</p>`;
            
            // Audio player controls
            const playPauseButton = audioControlsElement.querySelector('[data-action="play-pause"]');
            const addAudioButton = audioControlsElement.querySelector('[data-action="add-audio"]'); // New button reference
            const mainPagePlayPauseBtn = document.getElementById('playPauseMusicBtn'); // Main page play/pause button

            if (playPauseButton) {
                audioPlayerElement.addEventListener('play', () => { 
                    playPauseButton.textContent = '⏸'; 
                    // Pause background music if 3D viewer audio starts
                    if (backgroundMusicPlayer && !backgroundMusicPlayer.paused) {
                        backgroundMusicPlayer.pause();
                        isBackgroundMusicPlaying = true; // Mark as was playing
                    }
                    // Update main page player if it's the same audio
                    if (backgroundMusicPlayer && backgroundMusicPlayer.src === audioPlayerElement.src) {
                        mainPagePlayPauseBtn.textContent = '⏸';
                    }
                });
                audioPlayerElement.addEventListener('pause', () => { 
                    playPauseButton.textContent = '▶'; 
                    // Resume background music if 3D viewer audio pauses and it was playing before
                    if (backgroundMusicPlayer && isBackgroundMusicPlaying) {
                        backgroundMusicPlayer.play().catch(e => console.error("Error resuming background music:", e));
                    }
                    // Update main page player if it's the same audio
                    if (backgroundMusicPlayer && backgroundMusicPlayer.src === audioPlayerElement.src) {
                        mainPagePlayPauseBtn.textContent = '▶';
                    }
                });
                audioPlayerElement.addEventListener('ended', () => { 
                    playPauseButton.textContent = '▶'; 
                    // Resume background music if 3D viewer audio ends and it was playing before
                    if (backgroundMusicPlayer && isBackgroundMusicPlaying) {
                        backgroundMusicPlayer.play().catch(e => console.error("Error resuming background music:", e));
                    }
                    // Update main page player if it's the same audio
                    if (backgroundMusicPlayer && backgroundMusicPlayer.src === audioPlayerElement.src) {
                        mainPagePlayPauseBtn.textContent = '▶';
                    }
                });
                
                playPauseButton.addEventListener('click', () => {
                    if (audioPlayerElement.paused) {
                        audioPlayerElement.play().catch(e => console.error("Audio playback error:", e));
                    } else {
                        audioPlayerElement.pause();
                    }
                });
            }

            // New event listener for the add audio button
            if (addAudioButton) {
                addAudioButton.addEventListener('click', () => {
                    // Trigger the hidden audio file input
                    document.getElementById('modalAudioFileInput').click();
                });
            }

            // Return the viewer instance object with all its properties
            return { 
                scene, 
                camera, 
                renderer, 
                controls, 
                currentModel: null, // Currently loaded 3D model
                mixer: null, // Animation mixer for GLTF animations
                clock: new THREE.Clock(), // Clock for animation updates
                isCameraLocked: false, // State for camera lock
                autoRotate: true, // State for auto-rotation
                isBackgroundSolid: false, // State for background color
                isWireframe: false, // State for wireframe mode
                // Store initial states for reset functionality
                initialCameraPosition: camera.position.clone(),
                initialControlsTarget: controls.target.clone(),
                initialModelPosition: new THREE.Vector3(),
                initialModelRotation: new THREE.Euler(),
                initialModelScale: new THREE.Vector3(1,1,1),
                audioPlayer: audioPlayerElement, // Audio element
                audioControls: audioControlsElement, // Audio controls container
                hasAudioLoaded: false, // Flag if audio is loaded
            };
        }

        // Handles window resizing for the 3D viewer
        function onWindowResize3D(camera, renderer, container) {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // Animation loop for the 3D viewer
        function animate3D(viewerInstance) {
            if (!viewerInstance) return;
            requestAnimationFrame(() => animate3D(viewerInstance)); // Loop animation

            const delta = viewerInstance.clock.getDelta(); // Get time delta for animations

            if (viewerInstance.mixer) {
                viewerInstance.mixer.update(delta); // Update model animations
            }

            if (viewerInstance.currentModel && viewerInstance.autoRotate) {
                viewerInstance.currentModel.rotation.y += 0.015; // Auto-rotate model
            }

            viewerInstance.controls.update(); // Update OrbitControls
            viewerInstance.renderer.render(viewerInstance.scene, viewerInstance.camera); // Render scene
        }

        // Loads a 3D model into the viewer
        function loadModel(modelPath, viewerInstance, statusElement, controlsElement, fileInputLabelElement, audioControlsElement) {
            statusElement.classList.remove('hidden');
            statusElement.innerHTML = `<div class="loading-spinner mb-4"></div><p>Loading 3D Model... </p>`;
            
            // Hide controls and input label during loading
            if (fileInputLabelElement) fileInputLabelElement.classList.add('hidden');
            if (controlsElement) controlsElement.classList.add('hidden');
            if (audioControlsElement) audioControlsElement.classList.add('hidden');

            const loader = new THREE.GLTFLoader();
            loader.load(modelPath, (gltf) => {
                // Remove previous model if any
                if (viewerInstance.currentModel) {
                    viewerInstance.scene.remove(viewerInstance.currentModel);
                    if (viewerInstance.mixer) {
                        viewerInstance.mixer.stopAllAction();
                        viewerInstance.mixer = null;
                    }
                }
                viewerInstance.currentModel = gltf.scene;
                viewerInstance.scene.add(viewerInstance.currentModel);

                // Reset model states
                viewerInstance.isWireframe = false;
                viewerInstance.isBackgroundSolid = false;
                viewerInstance.renderer.setClearAlpha(0);
                if(controlsElement) controlsElement.querySelector('[data-action="toggle-wireframe"]').textContent = 'Wireframe';
                if(controlsElement) controlsElement.querySelector('[data-action="toggle-background"]').textContent = 'Toggle BG';

                // Play animations if present
                if (gltf.animations && gltf.animations.length) {
                    viewerInstance.mixer = new THREE.AnimationMixer(viewerInstance.currentModel);
                    gltf.animations.forEach((clip) => {
                        viewerInstance.mixer.clipAction(clip).play();
                    });
                }

                // Adjust camera to fit the loaded model
                const box = new THREE.Box3().setFromObject(viewerInstance.currentModel);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = viewerInstance.camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 1.5; // Add some buffer

                viewerInstance.camera.position.set(center.x, center.y, center.z + cameraZ);
                viewerInstance.controls.target.set(center.x, center.y, center.z);
                viewerInstance.controls.update();

                // Store initial positions for reset
                viewerInstance.initialCameraPosition.copy(viewerInstance.camera.position);
                viewerInstance.initialControlsTarget.copy(viewerInstance.controls.target);
                viewerInstance.initialModelPosition.copy(viewerInstance.currentModel.position);
                viewerInstance.currentModel.rotation.copy(viewerInstance.initialModelRotation);
                viewerInstance.currentModel.scale.copy(viewerInstance.initialModelScale);

                statusElement.classList.add('hidden'); // Hide loading status
                // Show controls and input label
                if (fileInputLabelElement) fileInputLabelElement.classList.remove('hidden');
                if (controlsElement) controlsElement.classList.remove('hidden');
                if (viewerInstance.hasAudioLoaded) { // Only show audio controls if audio is loaded
                    audioControlsElement.classList.remove('hidden');
                }

                // Revoke Blob URL if used
                if (modelPath.startsWith('blob:')) {
                    URL.revokeObjectURL(modelPath);
                }

            }, (xhr) => {
                // Update loading progress
                const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                statusElement.innerHTML = `<div class="loading-spinner mb-4"></div><p>Loading 3D Model... ${percent}%</p>`;
            }, (error) => {
                // Show error message
                statusElement.classList.remove('hidden');
                statusElement.innerHTML = `<p class="text-red-500">Error loading model: ${error.message || 'Unknown error'}</p>`;
                if (fileInputLabelElement) fileInputLabelElement.classList.remove('hidden');
                if (controlsElement) controlsElement.classList.add('hidden');
                if (audioControlsElement) audioControlsElement.classList.add('hidden');
                if (modelPath.startsWith('blob:')) {
                    URL.revokeObjectURL(modelPath);
                }
                console.error("Error loading 3D model:", error);
            });
        }

        // Sets up the resize handle for the 3D viewer container
        function setupResizeHandle3D(handle, container, camera, renderer) {
            let isResizing = false;
            let initialX, initialY, initialWidth, initialHeight;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                initialX = e.clientX;
                initialY = e.clientY;
                initialWidth = container.offsetWidth;
                initialHeight = container.offsetHeight;

                document.body.style.userSelect = 'none'; // Prevent text selection during resize
                document.body.style.cursor = 'nwse-resize'; // Change cursor
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;

                const minWidth = 300;
                const minHeight = 200;
                const maxWidth = window.innerWidth * 0.9;
                const maxHeight = window.innerHeight * 0.8;

                let newWidth = initialWidth + (e.clientX - initialX);
                let newHeight = initialHeight + (e.clientY - initialY);

                newWidth = Math.max(minWidth, Math.min(newWidth, maxWidth));
                newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));

                container.style.width = `${newWidth}px`;
                container.style.height = `${newHeight}px`;

                onWindowResize3D(camera, renderer, container); // Update renderer size
            });

            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.userSelect = ''; // Reset user select
                document.body.style.cursor = ''; // Reset cursor
            });
        }

        // Sets up controls for the 3D model (movement, rotation, etc.)
        function setupModelControls3D(controlsElement, viewerInstance, containerElement, fileInputLabelElement, uploadMenuElement) {
            const movementStep = 0.1;
            const scaleFactor = 1.05;

            // Function to update visibility of controls/labels based on hover/menu state
            const updateOverlayVisibility = () => {
                const isHovering = containerElement.matches(':hover');
                const isMenuOpen = !uploadMenuElement.classList.contains('hidden');

                // Check if currently in simulated fullscreen mode
                const isInSimulatedFullScreen = document.body.classList.contains('simulated-fullscreen-active');

                if (isInSimulatedFullScreen) {
                    // In simulated fullscreen, hide the file input label and model controls
                    fileInputLabelElement.classList.add('hidden');
                    controlsElement.classList.add('hidden');
                    viewerInstance.audioControls.classList.add('hidden');
                } else if (isHovering || isMenuOpen) {
                    fileInputLabelElement.classList.remove('hidden');
                    if (viewerInstance.currentModel) {
                        controlsElement.classList.remove('hidden');
                    }
                    viewerInstance.audioControls.classList.remove('hidden');
                } else {
                    fileInputLabelElement.classList.add('hidden');
                    controlsElement.classList.add('hidden');
                    viewerInstance.audioControls.classList.add('hidden');
                }
            };

            // Event listeners for showing/hiding controls on hover
            containerElement.addEventListener('mouseenter', updateOverlayVisibility);
            containerElement.addEventListener('mouseleave', updateOverlayVisibility);

            // Close upload menu if clicking outside
            document.addEventListener('click', (event) => {
                if (!uploadMenuElement.contains(event.target) && event.target !== fileInputLabelElement) {
                    uploadMenuElement.classList.add('hidden');
                    updateOverlayVisibility();
                }
            });

            // Toggle upload menu on '+' button click
            fileInputLabelElement.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent modal from closing
                uploadMenuElement.classList.toggle('hidden');
                updateOverlayVisibility();
            });

            // Handle clicks within the upload menu
            uploadMenuElement.addEventListener('click', (event) => {
                if (event.target.classList.contains('upload-menu-button')) {
                    const type = event.target.dataset.type;
                    uploadMenuElement.classList.add('hidden'); // Hide menu

                    if (type === 'model') {
                        // Trigger hidden model file input
                        fileInputLabelElement.closest('.model-viewer-container').querySelector('input[type="file"][accept=".gltf, .glb"]').click();
                    } else if (type === 'audio') {
                        // Trigger hidden audio file input
                        fileInputLabelElement.closest('.model-viewer-container').querySelector('input[type="file"][accept=".mp3"]').click();
                    }
                    updateOverlayVisibility();
                }
            });

            // Event listeners for all model control buttons
            controlsElement.querySelectorAll('.model-control-button').forEach(button => {
                button.addEventListener('click', () => {
                    const action = button.dataset.action;
                    if (!viewerInstance.currentModel) return; // Ensure a model is loaded

                    switch (action) {
                        case 'move-up':
                            viewerInstance.currentModel.position.y += movementStep;
                            break;
                        case 'move-down':
                            viewerInstance.currentModel.position.y -= movementStep;
                            break;
                        case 'move-left':
                            viewerInstance.currentModel.position.x -= movementStep;
                            break;
                        case 'move-right':
                            viewerInstance.currentModel.position.x += movementStep;
                            break;
                        case 'toggle-lock':
                            viewerInstance.isCameraLocked = !viewerInstance.isCameraLocked;
                            viewerInstance.controls.enabled = !viewerInstance.isCameraLocked; // Enable/disable OrbitControls
                            button.textContent = viewerInstance.isCameraLocked ? 'Unlock Cam' : 'Lock Cam';
                            break;
                        case 'reset-view':
                            // Reset camera and model to initial positions/rotations/scales
                            viewerInstance.camera.position.copy(viewerInstance.initialCameraPosition);
                            viewerInstance.controls.target.copy(viewerInstance.initialControlsTarget);
                            viewerInstance.currentModel.position.copy(viewerInstance.initialModelPosition);
                            viewerInstance.currentModel.rotation.copy(viewerInstance.initialModelRotation);
                            viewerInstance.currentModel.scale.copy(viewerInstance.initialModelScale);
                            viewerInstance.controls.update();

                            // Reset other states
                            viewerInstance.autoRotate = true;
                            controlsElement.querySelector('[data-action="toggle-rotation"]').textContent = 'Auto-Rotate';
                            viewerInstance.isWireframe = false;
                            viewerInstance.currentModel.traverse((node) => {
                                if (node.isMesh) { node.material.wireframe = false; }
                            });
                            controlsElement.querySelector('[data-action="toggle-wireframe"]').textContent = 'Wireframe';
                            viewerInstance.isBackgroundSolid = false;
                            viewerInstance.renderer.setClearAlpha(0);
                            controlsElement.querySelector('[data-action="toggle-background"]').textContent = 'Toggle BG';
                            break;
                        case 'toggle-rotation':
                            viewerInstance.autoRotate = !viewerInstance.autoRotate;
                            button.textContent = viewerInstance.autoRotate ? 'Auto-Rotate (Off)' : 'Auto-Rotate (On)';
                            break;
                        case 'scale-up':
                            viewerInstance.currentModel.scale.multiplyScalar(scaleFactor);
                            break;
                        case 'scale-down':
                            viewerInstance.currentModel.scale.multiplyScalar(1 / scaleFactor);
                            break;
                        case 'toggle-background':
                            viewerInstance.isBackgroundSolid = !viewerInstance.isBackgroundSolid;
                            if (viewerInstance.isBackgroundSolid) {
                                viewerInstance.renderer.setClearColor(0x333333, 1); // Set solid background color
                                button.textContent = 'Toggle BG (Solid)';
                            } else {
                                viewerInstance.renderer.setClearAlpha(0); // Set transparent background
                                button.textContent = 'Toggle BG (Transparent)';
                            }
                            break;
                        case 'toggle-wireframe':
                            viewerInstance.isWireframe = !viewerInstance.isWireframe;
                            viewerInstance.currentModel.traverse((node) => {
                                if (node.isMesh) {
                                    node.material.wireframe = viewerInstance.isWireframe; // Toggle wireframe on all meshes
                                }
                            });
                            button.textContent = viewerInstance.isWireframe ? 'Wireframe (On)' : 'Wireframe (Off)';
                            break;
                        case 'screenshot':
                            const canvas = viewerInstance.renderer.domElement;
                            const link = document.createElement('a');
                            link.download = 'model-screenshot.png';
                            link.href = canvas.toDataURL('image/png'); // Get canvas content as PNG
                            link.click(); // Trigger download
                            link.remove();
                            break;
                    }
                });
            });
        }

        // Initializes the 3D Viewer feature
        function init3DViewerFeature() {
            const modelContainer = document.getElementById('modalModelContainer');
            const modelCanvas = document.getElementById('modalModelCanvas');
            const modelStatus = document.getElementById('modalModelStatus');
            const primaryAudioPlayer = document.getElementById('modalPrimaryAudioPlayer');
            const audioControls = document.getElementById('modalAudioControls');
            const resizeHandle = document.getElementById('modalResizeHandle');
            const modelControls = document.getElementById('modalModelControls');
            const modelFileInput = document.getElementById('modalModelFileInput');
            const audioFileInput = document.getElementById('modalAudioFileInput');
            const modelFileInputLabel = document.getElementById('modalModelFileInputLabel');
            const uploadMenu = document.getElementById('modalUploadMenu');
            const mainPagePlayPauseBtn = document.getElementById('playPauseMusicBtn');


            // Initialize the Three.js viewer instance
            modalViewerInstance = init3DViewerInstance(modelCanvas, modelContainer, modelStatus, primaryAudioPlayer, audioControls);
            
            // Event listener for model file input
            modelFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    loadModel(URL.createObjectURL(file), modalViewerInstance, modelStatus, modelControls, modelFileInputLabel, audioControls);
                }
            });
            // Event listener for audio file input
            audioFileInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const audioURL = URL.createObjectURL(file);
                    
                    // Set the source for both players
                    modalViewerInstance.audioPlayer.src = audioURL;
                    backgroundMusicPlayer.src = audioURL;

                    // Play both players
                    modalViewerInstance.audioPlayer.play().catch(e => console.error("3D Viewer Audio playback error:", e));
                    backgroundMusicPlayer.play()
                        .then(() => {
                            mainPagePlayPauseBtn.textContent = '⏸';
                            isBackgroundMusicPlaying = true;
                            console.log("Background music playing from 3D viewer upload.");
                        })
                        .catch(error => {
                            console.error("Background music playback error from 3D viewer upload:", error);
                        });
                    
                    modalViewerInstance.hasAudioLoaded = true; // Set flag
                    audioControls.classList.remove('hidden'); // Show audio controls
                }
                event.target.value = ''; // Clear file input
            });
            // Setup resize handle
            setupResizeHandle3D(resizeHandle, modelContainer, modalViewerInstance.camera, modalViewerInstance.renderer);
            // Setup model controls
            setupModelControls3D(modelControls, modalViewerInstance, modelContainer, modelFileInputLabel, uploadMenu);

            animate3D(modalViewerInstance); // Start the animation loop

            // Load a default model on initialization
            loadModel('https://imelijah88.github.io/Avneed/metalady.glb', modalViewerInstance, modelStatus, modelControls, modelFileInputLabel, audioControls);
        }

        // --- Floating Balls Animation Logic ---
        const fixedHeaderContent = document.getElementById('fixedHeaderContent');
        const buttons = document.querySelectorAll('.sphere-button');

        let buttonStates = []; // Stores state for each floating button
        let animationFrameId = null; // To store the requestAnimationFrame ID

        // Initializes the positions and velocities of the floating buttons
        function initFloatingBalls() {
            // Cancel any existing animation frame to prevent multiple loops
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Get computed styles for padding of the main black box (sectionHeader)
            const computedStyle = window.getComputedStyle(sectionHeader);
            const paddingTop = parseFloat(computedStyle.paddingTop);
            const paddingLeft = parseFloat(computedStyle.paddingLeft);
            const paddingBottom = parseFloat(computedStyle.paddingBottom);
            const paddingRight = parseFloat(computedStyle.paddingRight);

            // Get the bounding rectangle of the fixed header content (logo, Avneed text, settings)
            const fixedHeaderRect = fixedHeaderContent.getBoundingClientRect();
            const sectionHeaderRect = sectionHeader.getBoundingClientRect();

            // Calculate the effective top boundary for the balls (below the fixed header content)
            const topBoundary = fixedHeaderRect.bottom - sectionHeaderRect.top + 10; // Add a small buffer

            // Calculate the overall boundaries of the sectionHeader for the balls
            const buttonWidth = 80; // Use actual button width
            const buttonHeight = 80; // Use actual button height

            const minX = paddingLeft;
            const maxX = sectionHeader.clientWidth - paddingRight - buttonWidth;
            const minY = topBoundary; 
            const maxY = sectionHeader.clientHeight - paddingBottom - buttonHeight; // Use clientHeight for the current height of the container

            console.log('--- Initializing Floating Balls ---');
            console.log('sectionHeader clientWidth:', sectionHeader.clientWidth);
            console.log('sectionHeader clientHeight:', sectionHeader.clientHeight);
            console.log('fixedHeaderRect.bottom:', fixedHeaderRect.bottom);
            console.log('sectionHeaderRect.top:', sectionHeaderRect.top);
            console.log('topBoundary:', topBoundary);
            console.log('minX:', minX, 'maxX:', maxX);
            console.log('minY:', minY, 'maxY:', maxY);


            buttonStates = Array.from(buttons).map(button => {
                let initialX = Math.random() * (maxX - minX) + minX;
                let initialY = Math.random() * (maxY - minY) + minY;

                // Ensure initial position is within the calculated bounds
                initialX = Math.max(minX, Math.min(initialX, maxX));
                initialY = Math.max(minY, Math.min(initialY, maxY));

                // Random initial velocity (reverted to original, slower multiplier)
                let vx = (Math.random() - 0.5) * 0.5; // Original multiplier
                let vy = (Math.random() - 0.5) * 0.5; // Original multiplier

                // Ensure minimum velocity to keep them moving
                if (Math.abs(vx) < 0.05) vx = vx > 0 ? 0.05 : -0.05; // Adjusted minimum velocity
                if (Math.abs(vy) < 0.05) vy = vy > 0 ? 0.05 : -0.05; // Adjusted minimum velocity

                // Set initial CSS position
                button.style.position = 'absolute';
                button.style.left = '0px'; 
                button.style.top = '0px';
                button.style.transform = `translate(${initialX}px, ${initialY}px)`;

                console.log(`Button ${button.id || button.textContent} initial pos: (${initialX.toFixed(2)}, ${initialY.toFixed(2)})`);
                console.log(`Button ${button.id || button.textContent} initial vel: (${vx.toFixed(2)}, ${vy.toFixed(2)})`);


                return {
                    element: button,
                    x: initialX,
                    y: initialY,
                    vx: vx,
                    vy: vy,
                };
            });

            animateBalls(); // Start the animation loop
        }

        // Animation loop for floating balls
        function animateBalls() {
            // Recalculate bounds on each frame to handle window resizing dynamically
            const computedStyle = window.getComputedStyle(sectionHeader);
            const paddingLeft = parseFloat(computedStyle.paddingLeft);
            const paddingBottom = parseFloat(computedStyle.paddingBottom);
            const paddingRight = parseFloat(computedStyle.paddingRight);

            const fixedHeaderRect = fixedHeaderContent.getBoundingClientRect();
            const sectionHeaderRect = sectionHeader.getBoundingClientRect();

            const topBoundary = fixedHeaderRect.bottom - sectionHeaderRect.top + 10; 
            
            const buttonWidth = 80; 
            const buttonHeight = 80; 
            
            const minX = paddingLeft;
            const maxX = sectionHeader.clientWidth - paddingRight - buttonWidth;
            const minY = topBoundary; 
            const maxY = sectionHeader.clientHeight - paddingBottom - buttonHeight; // Use clientHeight for the current height of the container

            buttonStates.forEach(ball => {
                // Update position
                ball.x += ball.vx;
                ball.y += ball.vy;

                // Collision detection and bounce off boundaries
                if (ball.x < minX) {
                    ball.x = minX;
                    ball.vx *= -1;
                } else if (ball.x > maxX) {
                    ball.x = maxX;
                    ball.vx *= -1;
                }

                if (ball.y < minY) {
                    ball.y = minY;
                    ball.vy *= -1;
                } else if (ball.y > maxY) {
                    ball.y = maxY;
                    ball.vy *= -1;
                }

                // Apply position using transform for smooth animation
                ball.element.style.transform = `translate(${ball.x}px, ${ball.y}px)`;
            });

            animationFrameId = requestAnimationFrame(animateBalls); // Request next frame
        }

        // --- Main DOM Content Loaded Listener ---
        document.addEventListener('DOMContentLoaded', () => {
            const toggleThemeBtn = document.getElementById('settingsBtn');
            const settingsMenu = document.getElementById('settingsMenu');
            let isSettingsMenuOpen = false;
            const featuresLink = document.getElementById('featuresLink'); // Get the Features link

            // Toggle settings menu visibility
            toggleThemeBtn.addEventListener('click', (event) => {
                event.stopPropagation(); // Prevent document click from closing it immediately
                isSettingsMenuOpen = !isSettingsMenuOpen;
                if (isSettingsMenuOpen) {
                    settingsMenu.classList.remove('hidden');
                    updateLoginStatusInSettingsMenu(!!userId, auth?.currentUser); // Update login status when opening
                } else {
                    settingsMenu.classList.add('hidden');
                }
            });

            // Close settings menu if clicking outside
            document.addEventListener('click', (event) => {
                if (isSettingsMenuOpen && !settingsMenu.contains(event.target) && event.target !== toggleThemeBtn) {
                    settingsMenu.classList.add('hidden');
                    isSettingsMenuOpen = false;
                }
            });

            // Theme switching logic
            settingsMenu.querySelectorAll('.settings-menu-button[data-theme]').forEach(button => {
                button.addEventListener('click', () => {
                    const theme = button.dataset.theme;
                    document.body.classList.remove('dark-theme', 'light-theme'); // Remove existing themes
                    document.body.classList.add(theme + '-theme'); // Add selected theme
                    localStorage.setItem('theme', theme); // Save preference
                    settingsMenu.classList.add('hidden'); // Hide menu
                    isSettingsMenuOpen = false;
                });
            });

            // Apply stored theme on load
            const storedTheme = localStorage.getItem('theme') || 'dark';
            document.body.classList.add(storedTheme + '-theme');

            // Event listeners for opening AI feature content (using data-feature-id)
            document.querySelectorAll('.sphere-button').forEach(button => {
                button.addEventListener('click', (event) => {
                    const featureId = event.currentTarget.dataset.featureId;
                    if (featureId) {
                        showFeatureContent(featureId);
                    }
                });
            });

            // Add event listener to the "Features" link to reset animation
            if (featuresLink) {
                featuresLink.addEventListener('click', (event) => {
                    event.preventDefault(); // Prevent default anchor link behavior
                    initFloatingBalls(); // Reset the floating balls animation
                    // You might also want to scroll to the top of the features section if it's not already visible
                    document.getElementById('ai-features').scrollIntoView({ behavior: 'smooth' });
                });
            }

            // Initialize floating balls animation after DOM is ready
            initFloatingBalls();
            // Re-initialize on resize to adjust bounds
            window.addEventListener('resize', () => {
                // Only re-initialize if no feature is active (to prevent re-randomizing positions when the header is expanded for a feature)
                // When a feature is active, initFloatingBalls is called by showFeatureContent/closeFeatureContent
                if (!activeFeatureId) {
                    initFloatingBalls();
                }
            });
        });
    </script>
</body>
</html>
